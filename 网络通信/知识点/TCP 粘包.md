## TCP 粘包

## 一、为什么会出现粘包

主要原因就是**tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发**。

“粘包”可发生在发送端也可发生在接收端：

* 由Nagle算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当我们提交一段数据给TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。
* 接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP的数据取出来，就会造成TCP缓冲区中存放了几段数据。

##### 其他的描述

- TCP发送方：TCP本身传输的数据包大小有限制，如果应用发出的消息包过大，TCP会把应用消息包拆分为多个TCP数据包发送出去；如果应用发送数据包太小，TCP为了减少网络请求次数的开销，它会等待多个消息包一起，打成一个TCP数据包一次发送出去。
- TCP接收方：**TCP 缓冲区里的数据都是字符流的形式，没有明确的边界**，因为数据没边界，所以应用从TCP缓冲区中读取数据时就没办法指定一个或几个消息一起读，而**只能选择一次读取多大的数据流**，而这个数据流中就可能包含着某个消息包的一部分数据。

从上面的讲述可以看到**数据的接收和发送是无关的，不是同步的：`read()`函数不管数据发送了多少次，都会尽可能多的接收数据。也就是说，`read()`和`write()`的执行次数可能不同**。

> 例如，`write()`重复执行三次，每次都发送字符串"abc"，那么目标机器上的`read()`可能分三次接收，每次都接收"abc"；也可能分两次接收，第一次接收"abcab"，第二次接收"cabc"；也可能一次就接收到字符串"abcabcabc"。
> 再举个例子，A 与 B 进行 TCP 通信，A 先后给 B 发送了一个 100 字节和 200 字节的数据包，那么 B 是如何收到呢？B 可能先收到 100 字节，再收到 200 字节；也可能先收到 50 字节，再收到 250 字节；或者先收到 100 字节，再收到 100 字节，再收到 200 字节；或者先收到 20 字节，再收到 20 字节，再收到 60 字节，再收到 100 字节，再收到 50 字节，再收到 50 字节……

这样就产生了数据的粘包和半包问题，**客户端发送的多个数据包被当做一个数据包接收或者半个数据包**。也称数据的无边界性，`read()`函数不知道数据包的开始或结束标志（实际上也没有任何开始或结束标志），只把它们当做连续的数据流来处理。

所以无论是半包还是粘包问题，其根源是**流式数据格式（面向字节流的协议），数据无边界**。因此**TCP 才会产生数据的粘包和半包问题**，而 UDP 一般并不会产生这两个问题，因为 **UDP 是面向报文的协议，有明确的边界**。

## 二、解决

### 1、定长消息

例如我们可以规定每个协议包的大小是 64 个字节，每次收满 64 个字节，就取出来解析，如果不够就先存起来。

**特点**：

- 这种通信协议的格式简单但灵活性差：如果数据包内容不够指定的字节数，剩余的空间需要填充特殊的信息，如 `\0`；如果包内容超过指定字节数又得分包分片，需要增加额外处理逻辑，即在发送端进行分包分片，在接收端重新组装包片。
- 消息很短时, 效率很低, 浪费带宽。

出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。

### 2、特殊标志作为结束标志

这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。

> 例如，我们熟悉的 FTP协议、发邮件的 SMTP 协议，一个命令或者一段数据后面加上"\r\n"（即所谓的**CRLF**）表示一个包的结束。接收端每遇到一个”\r\n“就把之前的数据当做一个数据包。

缺点: 如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析。

### 3、包头 + 包体格式

HTTP 协议的消息边界就是基于长度实现的。我们使用 `Content-Length` 头表示 HTTP 消息的负载大小，当应用层协议解析到足够的字节数后，就能从中分离出完整的 HTTP 消息，无论发送方如何处理对应的数据包，我们都可以遵循这一规则完成 HTTP 消息的重组。

这种格式的数据包一般分为两部分：包头和包体。包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。

![440w.webp](https://pic1.imgdb.cn/item/64735269f024cca173d12927.webp)

这就是一个典型的包头格式，包体长度指定了这个包的包体是多大。由于包头大小是固定的，接收端先收取包头大小字节数目（当然如果不够还是先缓存起来，直到收够为止），然后解析包头，根据包头中指定的包体大小来收取包体，等包体收够了，就组装成一个完整的包来处理。

在有些实现中，包头中的包体长度可能被另外一个包长度的字段代替，这个字段的含义是整个包的大小，这个时候，我们只要用包长度减去包头大小就能算出包体的大小，原理同上。

封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度。

拆包：根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。

## 三、示例

详见socket章节笔记

## 四、其他

### 1、什么时候不需要考虑粘包问题？

- 如果 TCP 是短连接，即只进行一次数据通信过程，通信完成就关闭连接，这样就不会出现粘包问题。
- 如果传输的是字符串、文件等无结构化数据时，也不会出现粘包问题。因为发送方只管发送，接收方只管接收存储就行了。
