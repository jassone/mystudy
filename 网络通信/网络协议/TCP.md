
## TCP
TCP（Transmission Control Protocol，传输控制协议）

<font color="red">TCP是一种**面向连接**（连接导向）的、**可靠的**基于**字节流**的传输层通信协议。</font>TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。

TCP的特点有：





* **TCP是面向连接的运输层协议**
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
* **TCP提供可靠的服务**
* TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。
* 面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。

### 1、TCP头格式
![731719-20160520221735216-981482756.png](https://pic.imgdb.cn/item/612f31de44eaada739a07aa5.png)

1. Source Port（源端口号）：数据发起者的端口号，16bit。
2. Destination Port（目的端口号）：数据接收者的端口号，16bit。
3. Sequence Number（顺序号码，Seq）：用于在数据通信中解决网络包乱序（reordering）问题，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个顺序号码来拼接数据），32bit。
4. Acknowledgment Number（确认号码，ack）：是数据接收方期望收到发送方在下一个报文段的顺序号码（Seq），因此确认号码应当是上次已成功收到顺序号码（Seq）加1，32bit。
5. Offset（TCP报文头长度)：用于存储报文头中有多少个32bit(上图的一行)，存储长度为4bit，最大可表示
```
```*32bit=60bytes的报文头。最小取值5，5*32bit=20bytes。
1. Reserved（保留）：6bit, 均为0

3. TCP Flags（TCP标志位）每个长度均为1bit
CWR：压缩，TCP Flags值0x80。
ECE：拥塞，0x40。
URG：紧急，0x20。当URG=1时，表示报文段中有紧急数据，应尽快传送。
ACK：**确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。**
PSH：推送，0x08。当发送端PSH=1时，接收端尽快的交付给应用进程。
RST：复位，0x04。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。
SYN：同步，0x02。在建立连接是用来同步序号。**SYN=1， ACK=0表示一个连接请求报文段。SYN=1(发送)，ACK=1(回复)表示同意建立连接。**
FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。
8. 窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。
9. 检验和：该字段检验的范围包括头部和数据这两部分。由发端计算和存储，并由收端进行验证。
10. 紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。
11. TCP选项：长度可变，最长可达40字节

备注：ISN（Inital Sequence Number）：初始化Sequence Number，发生在建立连接时。

```

### 2、三次挥手
##### 三次挥手过程描述

![0a58409c043b42f9b20c9e07b60f346.png](https://pic.imgdb.cn/item/617578a92ab3f51d915994ae.png)

1. 第一次握手: 客户端发送syn标志位和seq num，向服务器申请建立连接，客户端状态由closed变为syn_send

2. 第二次握手: 服务端返回 syn和ack标志位，ack num以及seq num，确认第一次握手的报文段，返回ack num=seq num(第一次握手发送的)+1，同意建立连接，服务器状态由listen变为syn_received

3. 第三次握手: 发送确认报文段，返回ack以及ack num=seq num(第二次握手发送的)+1，客户端状态变为：established(完成连接)

最后: 服务器收到确认报文段，服务器状态由syn_received变为established(完成连接)

实例演示过程(开两个窗口，一个监控一个请求)
```sh
➜  ~ git:(master) ✗ sudo tcpdump -nn -i en0 port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes

####### 三次握手开始
23:23:16.121091 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [S], seq 2822940233, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1776709941 ecr 0,sackOK,eol], length 0
23:23:16.134686 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [S.], seq 4198932997, ack 2822940234, win 8192, options [mss 1412,nop,wscale 5,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,sackOK,eol], length 0
23:23:16.135014 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1, win 4096, length 0

#######开始传输
23:23:16.135161 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [P.], seq 1:78, ack 1, win 4096, length 77: HTTP: GET / HTTP/1.1
# length 77，为http请求头大小；P表示客户端已经把数据包都发过去了，请服务端赶紧处理

23:23:16.145106 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], ack 78, win 908, length 0
# 服务端收到了请求包，赶紧回复一个确认

23:23:16.146406 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], seq 1:1413, ack 78, win 908, length 1412: HTTP: HTTP/1.1 200 OK
# 同时开始解析请求头，返回数据包，长度1412

23:23:16.146538 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1413, win 4073, length 0
# 客户端收到返回数据包，回复一个确认

23:23:16.146920 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [P.], seq 1413:1441, ack 78, win 908, length 28: HTTP
# 服务端继续发送第二个数据包，长度28，P表示服务端告知客户端我已经发送完所有数据包，请赶紧处理

23:23:16.147008 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1441, win 4095, length 0
# 客户端返回一个收到确认

23:23:16.148517 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [P.], seq 1441:2782, ack 78, win 908, length 1341: HTTP
23:23:16.148599 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 2782, win 4075, length 0
#？？？？
```

三次握手后，开始开辟资源，建立连接(连接即双方内存资源连接和规则，即socket)  ，空间上，TCP需要在端系统中维护连接状态。

双方建立连接后，如果中间网络断开，各自都不能感知到，但是内核会定时从客户端发送心跳包(keep-alive)到服务端，来检查连接是还在，并把结果告诉应用层。该心跳检测只是检测当前这个连接是否正常。

应用层面的心跳检查：是为了检查当前应用是否可以，如果不可用，切换到其他应用，是检查角色是否可用的。

扩展：建立连接后，1年后未发送数据，连接是否有效？
我们认为是有效的，但是可能网络环境发送变化或断线等，一旦通信是不通的。这时候常规做法是使用心跳去监控连接。

##### 三次握手作用

* TCP 的三次握手除了建立连接外(非物理连接)，主要还是为了沟通 TCP 包的序号问题。

##### 三次握手原因

* <font color="red">TCP连接的特性决定，一次RT(往返)完成一次TCP的动作(即客户端和服务端都要保证一次一发一收成功，因为网络通信/IO通信是双向的，有输入就有输出)。</font>

    即客户端一次请求携带的seq num必须得到服务端的ack num才会完成。如果没有返回确认报文段，由于重发机制，定时器经过了一次RTO，客户端就会重发报文。那为什么客户端最后一次发送之后，没有等待服务端发回ack报文段？ 这是因为服务端第二次发送的报文段里 包含ack以及请求syc报文，相当于把确认报文和请求报文合并了，所以最后客户端回复一个ack报文即可。

* 防止失效的报文创建连接。

    因为互联网链路是非常复杂的，发送的报文可能会被互联中的网络设备阻塞，经过了一段时间才到达服务器，时间大于了RTO(Retransmission TimeOut)时间，导致客户端重发syc报文(重新创建新的连接，并丢失超时的连接)。如果只有两次握手，那么服务器每接收到syc报文(包括重发的syc报文)，就会创建多余的连接，造成服务器的资源浪费。如果有第三次握手，那么客户端就能够识别出服务端发出的syc和ack报文对应的请求连接在客户端是否存活，如果存活则发送第三次握手ack报文，确认建立连接。


### 3、四次挥手
##### 四次挥手过程描述

![2021030816234519.png](https://pic.imgdb.cn/item/612f459744eaada739c1f4cc.png)

1. 第一次挥手: 客户端的应用说要关闭连接，给服务端发送一个含fin标志位的报文，客户端状态由established变为fin-wait-1

2. 第二次挥手: 服务端收到客户端发来的fin报文，回复ack报文，告知服务端的应用要关闭连接，服务端状态由established变为close-wait，而客户端收到ack报文后，状态由fin-wait-1变为fin-wait-2

3. 第三次挥手: 服务端应用说可以关闭连接了，给客户端发送fin报文，服务端状态由close-wait变为last-ack

4. 第四次挥手: 客户端收到服务端发来的fin报文，回复ack报文，客户端状态由fin-wait-2变为time-wait，服务端收到ack报文后，直接关闭连接，状态由last-ack变为closed

客户端经过两次最大的报文存活时间后，关闭连接，状态由time-wait变为closed。因为但是如果服务端没有接收到 客户端跑路的 ACK 呢，就再也接收不到了，所以这时候客户端需要等待一段时间，因为如果服务端没接收到客户端的 ACK 的话会重新发送给客户端，所以 的等待时间需要足够长。


实例演示过程
```sh
####### 四次挥手
23:23:16.148932 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [F.], seq 78, ack 2782, win 4096, length 0
# 客户端告知服务端，我要断开了链接了

23:23:16.157961 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], ack 79, win 908, length 0
# 服务端回复知道了

23:23:16.158210 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [F.], seq 2782, ack 79, win 908, length 0
# 服务端回复现在可以断开链接了

23:23:16.158326 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 2783, win 4096, length 0
# 客户端回复我这边断开连接了
```
##### 四次挥手作用

* 是为了双方结束连接，各自释放内存资源。

##### 四次挥手原因

* 假设只有二次挥手客户端发送fin报文，服务端接收fin后，返回ack报文。客户端接收到ack报文后，断开连接。然而服务器可能还有**没有发送完成的报文**，当发送数据报文给客户端，发现客户端已经断开连接。服务端还没发送完的报文段就会抛客户端失去连接的异常。所以需要等待服务端也主动关闭。

* 假设只有三次挥手， 服务端就不能及时地关闭连接，导致连接空闲一段时间，浪费资源。

### 4、通过序列号与确认应答提高可靠性
TCP传输数据的过程中，每次接收方收到数据后，都会对传输方进行确认应答，也就是会发送ACK报文。这个ACK报文中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。

序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

![84a3e2220fa42a_png.png](https://pic.imgdb.cn/item/617525e72ab3f51d91128efc.png)

### 5、利用窗口控制提高速度
 ![share4545.jpg](https://pic.imgdb.cn/item/617520782ab3f51d910e9e1e.jpg)

### 6、窗口控制与重发控制-TODO
### 7、流控制-TODO
### 8、拥塞控制-TODO
### 9、窗口大小与吞吐量
![332323324.jpg](https://pic.imgdb.cn/item/617527262ab3f51d91137a83.jpg)



todo  

请问如何提升TCP三次握手的性能？
https://zhuanlan.zhihu.com/p/198089844