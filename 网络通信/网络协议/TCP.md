## TCP

TCP（Transmission Control Protocol，传输控制协议）

<font color="red">TCP是一种**面向连接**（连接导向）的、**可靠的**基于**字节流**的传输层通信协议。</font>TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认、对失序的数据重新排序、丢弃重复数据。

TCP的特点有：

* **TCP是面向连接的传输层协议**
* 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的
* **TCP提供可靠的服务**
* TCP提供全双工通信。数据在两个方向上独立的进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。
* 面向字节流。面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序交下来的数据仅仅是一连串的无结构的字节流。

## 一、基础知识

### 1、TCP头格式

![731719-20160520221735216-981482756.png](https://pic.imgdb.cn/item/612f31de44eaada739a07aa5.png)

1. Source Port（源端口号）：数据发起者的端口号，16bit。
2. Destination Port（目的端口号）：数据接收者的端口号，16bit。
3. Sequence Number（顺序号码，Seq）：用于在数据通信中解决网络包乱序（reordering）问题，以保证应用层接收到的数据不会因为网络上的传输问题而乱序（TCP会用这个顺序号码来拼接数据），32bit。
4. Acknowledgment Number（确认号码，ack）：是数据接收方期望收到发送方在下一个报文段的顺序号码（Seq），因此确认号码应当是上次已成功收到顺序号码（Seq）加1，32bit。
5. Offset（TCP报文头长度)：用于存储报文头中有多少个32bit(上图的一行)，存储长度为4bit，最大可表示
```
```*32bit=60bytes的报文头。最小取值5，5*32bit=20bytes。
1. Reserved（保留）：6bit, 均为0

3. TCP Flags（TCP标志位）每个长度均为1bit
CWR：压缩，TCP Flags值0x80。
ECE：拥塞，0x40。
URG：紧急，0x20。当URG=1时，表示报文段中有紧急数据，应尽快传送。
ACK：**确认，0x10。当ACK = 1时，代表这是一个确认的TCP包，取值0则不是确认包。**
PSH：推送，0x08。当发送端PSH=1时，接收端尽快的交付给应用进程。
RST：复位，0x04。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接。
SYN：同步，0x02。在建立连接是用来同步序号。**SYN=1， ACK=0表示一个连接请求报文段。SYN=1(发送)，ACK=1(回复)表示同意建立连接。**
FIN：终止，0x01。当FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。
8. 窗口：用来控制对方发送的数据量，通知发放已确定的发送窗口上限。
9. 检验和：该字段检验的范围包括头部和数据这两部分。由发端计算和存储，并由收端进行验证。
10. 紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。
11. TCP选项：长度可变，最长可达40字节

备注：ISN（Inital Sequence Number）：初始化Sequence Number，发生在建立连接时。

```

### 2、三次挥手
##### 三次挥手过程描述

![0a58409c043b42f9b20c9e07b60f346.png](https://pic.imgdb.cn/item/617578a92ab3f51d915994ae.png)

1. 第一次握手: 客户端发送syn标志位和seq num，向服务器申请建立连接，客户端状态由closed变为syn_send

2. 第二次握手: 服务端返回 syn和ack标志位，ack num以及seq num，确认第一次握手的报文段，返回ack num=seq num(第一次握手发送的)+1，同意建立连接，服务器状态由listen变为syn_received

3. 第三次握手: 发送确认报文段，返回ack以及ack num=seq num(第二次握手发送的)+1，客户端状态变为：established(完成连接)

最后: 服务器收到确认报文段，服务器状态由syn_received变为established(完成连接)

实例演示过程(开两个窗口，一个监控一个请求)
```sh
➜  ~ git:(master) ✗ sudo tcpdump -nn -i en0 port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on en0, link-type EN10MB (Ethernet), capture size 262144 bytes

####### 三次握手开始
23:23:16.121091 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [S], seq 2822940233, win 65535, options [mss 1460,nop,wscale 6,nop,nop,TS val 1776709941 ecr 0,sackOK,eol], length 0
23:23:16.134686 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [S.], seq 4198932997, ack 2822940234, win 8192, options [mss 1412,nop,wscale 5,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,sackOK,eol], length 0
23:23:16.135014 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1, win 4096, length 0

#######开始传输
23:23:16.135161 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [P.], seq 1:78, ack 1, win 4096, length 77: HTTP: GET / HTTP/1.1
# length 77，为http请求头大小；P表示客户端已经把数据包都发过去了，请服务端赶紧处理

23:23:16.145106 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], ack 78, win 908, length 0
# 服务端收到了请求包，赶紧回复一个确认

23:23:16.146406 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], seq 1:1413, ack 78, win 908, length 1412: HTTP: HTTP/1.1 200 OK
# 同时开始解析请求头，返回数据包，长度1412

23:23:16.146538 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1413, win 4073, length 0
# 客户端收到返回数据包，回复一个确认

23:23:16.146920 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [P.], seq 1413:1441, ack 78, win 908, length 28: HTTP
# 服务端继续发送第二个数据包，长度28，P表示服务端告知客户端我已经发送完所有数据包，请赶紧处理

23:23:16.147008 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 1441, win 4095, length 0
# 客户端返回一个收到确认

23:23:16.148517 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [P.], seq 1441:2782, ack 78, win 908, length 1341: HTTP
23:23:16.148599 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 2782, win 4075, length 0
#？？？？
```

三次握手后，开始开辟资源，建立连接(连接即双方内存资源连接和规则，即socket)  ，空间上，TCP需要在端系统中维护连接状态。

双方建立连接后，如果中间网络断开，各自都不能感知到，但是内核会定时从客户端发送心跳包(keep-alive)到服务端，来检查连接是还在，并把结果告诉应用层。该心跳检测只是检测当前这个连接是否正常。

应用层面的心跳检查：是为了检查当前应用是否可以，如果不可用，切换到其他应用，是检查角色是否可用的。

扩展：建立连接后，1年后未发送数据，连接是否有效？
我们认为是有效的，但是可能网络环境发送变化或断线等，一旦通信是不通的。这时候常规做法是使用心跳去监控连接。

##### 三次握手作用

* **TCP 的三次握手除了建立连接外(非物理连接)，主要还是为了沟通 TCP 包的序号问题**。

##### 三次握手原因

* <font color="red">TCP连接的特性决定，一次RT(往返)完成一次TCP的动作(即客户端和服务端都要保证一次一发一收成功，因为网络通信/IO通信是双向的，有输入就有输出)。</font>

    即客户端一次请求携带的seq num必须得到服务端的ack num才会完成。如果没有返回确认报文段，由于重发机制，定时器经过了一次RTO，客户端就会重发报文。那为什么客户端最后一次发送之后，没有等待服务端发回ack报文段？ 这是因为服务端第二次发送的报文段里 包含ack以及请求syc报文，相当于把确认报文和请求报文合并了，所以最后客户端回复一个ack报文即可。

* 防止失效的报文创建连接。

    因为互联网链路是非常复杂的，发送的报文可能会被互联中的网络设备阻塞，经过了一段时间才到达服务器，时间大于了RTO(Retransmission TimeOut)时间，导致客户端重发syc报文(重新创建新的连接，并丢失超时的连接)。如果只有两次握手，那么服务器每接收到syc报文(包括重发的syc报文)，就会创建多余的连接，造成服务器的资源浪费。如果有第三次握手，那么客户端就能够识别出服务端发出的syc和ack报文对应的请求连接在客户端是否存活，如果存活则发送第三次握手ack报文，确认建立连接。

### 3、四次挥手

##### 四次挥手过程描述

![2021030816234519.png](https://pic.imgdb.cn/item/612f459744eaada739c1f4cc.png)

1. 第一次挥手: 客户端的应用说要关闭连接，给服务端发送一个含fin标志位的报文，客户端状态由established变为fin-wait-1

2. 第二次挥手: 服务端收到客户端发来的fin报文，回复ack报文，告知服务端的应用要关闭连接，服务端状态由established变为close-wait，而客户端收到ack报文后，状态由fin-wait-1变为fin-wait-2

3. 第三次挥手: 服务端应用说可以关闭连接了，给客户端发送fin报文，服务端状态由close-wait变为last-ack

4. 第四次挥手: 客户端收到服务端发来的fin报文，回复ack报文，客户端状态由fin-wait-2变为time-wait，**服务端收到ack报文后，直接关闭连接**，状态由last-ack变为closed

**客户端经过两次最大的报文存活时间后，关闭连接，状态由time-wait变为closed**。因为如果服务端没有接收到 客户端跑路的 ACK 呢，就再也接收不到了，所以这时候客户端需要等待一段时间，因为如果服务端没接收到客户端的 ACK 的话会重新发送给客户端，所以等待时间需要足够长。


实例演示过程
```sh
####### 四次挥手
23:23:16.148932 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [F.], seq 78, ack 2782, win 4096, length 0
# 客户端告知服务端，我要断开了链接了

23:23:16.157961 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [.], ack 79, win 908, length 0
# 服务端回复知道了

23:23:16.158210 IP 36.152.44.96.80 > 192.168.1.8.54152: Flags [F.], seq 2782, ack 79, win 908, length 0
# 服务端回复现在可以断开链接了

23:23:16.158326 IP 192.168.1.8.54152 > 36.152.44.96.80: Flags [.], ack 2783, win 4096, length 0
# 客户端回复我这边断开连接了
```
##### 四次挥手作用

* 是为了双方结束连接，各自释放内存资源。

##### 四次挥手原因

* 假设只有二次挥手客户端发送fin报文，服务端接收fin后，返回ack报文。客户端接收到ack报文后，断开连接。然而服务器可能还有**没有发送完成的报文**，当发送数据报文给客户端，发现客户端已经断开连接。服务端还没发送完的报文段就会抛客户端失去连接的异常。所以需要等待服务端也主动关闭。

* 假设只有三次挥手， 服务端就不能及时地关闭连接，导致连接空闲一段时间，浪费资源。

### 4、通过序列号与确认应答提高可靠性
TCP传输数据的过程中，**每次接收方收到数据后，都会对传输方进行确认应答，也就是会发送ACK报文**。

- ACK报文中带有对应的确认序列号，起到应答的作用。告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
- 序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。


![84a3e2220fa42a_png.png](https://pic.imgdb.cn/item/617525e72ab3f51d91128efc.png)



## 二、数据传输过程
### 1、超时重传
超时重传机制用来保证TCP传输的可靠性。每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq 号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。

### 2、快速重传
接受数据一方发现有数据包丢掉了。就会发送ack报文告诉发送端重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。

超时重传 VS 快速重传：
超时重传：发送端在傻等超时，然后触发超时重传;
快速重传：接收端主动告诉发送端数据没收到，然后触发发送端重传。

### 3、流量控制
TCP滑动窗，用来做流量控制，是提高TCP传输效率的一种机制。

TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。

##### 利用窗口控制提高速度

![share4545.jpg](https://pic.imgdb.cn/item/617520782ab3f51d910e9e1e.jpg)

##### 窗口大小与吞吐量

![332323324.jpg](https://pic.imgdb.cn/item/617527262ab3f51d91137a83.jpg)

### 4、拥塞控制

流量控制 VS 拥塞控制
流量控制：只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况
拥塞控制：基于整个网络来考虑的

场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多 的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风 暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。

拥塞策略算法主要包括：慢启动/**慢开始**，拥塞避免，拥塞发生，快速恢复。

##### 慢启动/**慢开始**

刚开始cwnd=1，发送窗口也为1，发送方先发送一个报文M1测试连接通畅程度，当收到对M1报文的确认之后，cwnd呈指数级增长。

##### 拥塞避免
让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。
##### 快重传
当不出现丢包情况时，接收方是每接收多个数据包才给发送方一个确认。快重传算法要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方尽早知道有报文段没有到达接收方。
##### 快恢复
当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法

慢开始门限状态变量ssthresh
当 cwnd < ssthresh 时，使用慢开始算法（cwnd每轮加倍）。
当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。
拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。
当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。

可以看到，开始时采用慢开始算法，每经历一轮cwnd翻倍，传输的数据包翻倍，到第4轮时cwnd=16，意味着可以同时发送16个数据包，到达了设定的慢开始门限值ssthresh，随后采用拥塞避免算法。

采用拥塞避免算法期间，每经历一轮cwnd+1。当cwnd=24时，发送方不能准时收到确认数据包（即丢包），判断出现网络拥塞，于是把慢开始门限值ssthresh重新设为当前cwnd值（24）的一半，即12，并把cwnd重置为1 ，再次进入慢开始阶段。

可以看到：采用慢开始算法，cwnd按指数规律增长；采用拥塞避免算法，cwnd按线性规律增长。

todo  https://blog.csdn.net/Martin_chen2/article/details/123076397

## 三、相关问题

### 1、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

### 2、为什么要有TIME_WAIT状态

**1. 为了可靠地关闭TCP连接**

举例：我们把主动断开连接的一方称为C端，被动断开连接的一方称为S端，由于网络不可靠，C端发送的最后一个ACK报文可能没成功发送到S端，那么S端就会重新发上一个报文即FIN，如果C端处于TIME_WAIT状态下，就可以重新发送报文ACK，然后重新计时2MSL时间才会进入CLOSED状态，S端收到ACK后就可以正常关闭TCP连接了。反之，如果这时C端处于 CLOSED 状态 ，就会响应 RST报文而不是ACK报文，那S端会认为这是一个错误，只能异常关闭TCP连接

**2. 防止上一次连接中的包，迷路后重新出现，影响新连接**

由于网络的不可靠，TCP分节可能因为路由器异常而“迷途”，在迷途期间，TCP发送端会因确认超时而重发这个分节，这个分节最终被发送到对方时，对方可能已经是一个新的连接了，由此造成混乱。举例：关闭一个TCP链接后，马上又创建了一个相同的IP地址和端口之间的TCP链接，后一个链接被称为前一个链接的化身（incarnation)，那么此时有可能出现这种状况，前一个链接的迷途重复分节在前一个链接终止后出现了，从而被误解成从属于新的连接的数据。为了不出现这种混乱，TCP不容许处于TIME_WAIT状态的连接立即启动一个新连接，由于TIME_WAIT状态持续2MSL，就能够保证当成功创建一个TCP链接的时候，来自前一个连接的迷途重复分节已经在网络中消逝

### 2、time_wait和close_wait产生过多的原因和解决方法

补充：高并发场景下，大量time_wait是正常的

产生原因：

1. 业务上使用了持续且大量的短连接。

比如http请求中connection的值被设置成close，因为服务器处理完http请求后会主动断开连接，然后这个连接就处于TIME_WAIT状态了。持续时间长且量级较大的话，问题就显现出来了。http洗衣1.0中，connection默认为close，但在http1.1中connection默认行为是keep-alive，就是因为这个原因

3. HTTP 长连接超
4.  HTTP 长连接的请求数量达到上限

### 3、CLOSE_WAIT 状态的连接过多的原因

原因是程序没有调用 close 函数关闭连接。

可能是因为代码漏处理，或者是在执行 close 函数之前，代码卡在某一个逻辑，比如发生死锁等等。

可以发现，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，通常都是代码的问题，这时候我们需要针对具体的代码一步一步的进行排查和定位，主要分析的方向就是服务端为什么没有调用 close**。



https://www.cnblogs.com/gaoyanbing/p/16406873.html

https://blog.csdn.net/weixin_44718794/article/details/108649255

https://www.cnblogs.com/cheyunhua/p/17004942.html

todo  

请问如何提升TCP三次握手的性能？
https://zhuanlan.zhihu.com/p/198089844