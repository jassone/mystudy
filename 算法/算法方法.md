## 算法方法
## 一、双指针法（快慢指针法）
通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

### 1、注意点
* 如何定义双指针
* 快慢指针赋值问题

### 2、时间复杂度
* 暴力解法时间复杂度：O(n^2)
* 双指针时间复杂度：O(n)

## 二、归并排序
### 1、时间复杂度
* O(nlogn)

## 三、滑动窗口
滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2 )的暴力解法降为O(n)。

### 1、时间复杂度
* 暴力解法时间复杂度：O(n^2 )
* 滑动窗口时间复杂度：O(n)

## 四、二分法
### 1、注意点
* 区间必须是单调的
* **循环不变量原则**

### 2、时间复杂度
* 暴力解法时间复杂度：O(n)
* 二分法时间复杂度：**O(logn)**

### 3、适用场景
* 寻找目标值
* 寻找上下界

## 五、模拟行为
模拟类的题目在数组中很常见，不涉及到什么算法，就是单纯的模拟，十分考察大家对代码的掌控能力。

在这道题目中，我们再一次介绍到了**循环不变量原则**，其实这也是写程序中的重要原则。

相信大家又遇到过这种情况： 感觉题目的边界调节超多，一波接着一波的判断，找边界，踩了东墙补西墙，好不容易运行通过了，代码写的十分冗余，毫无章法，**其实真正解决题目的代码都是简洁的，或者有原则性的。**

## 六、递归
### 1、三部曲
* 确定递归函数(即下一个循环)的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

* 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

* 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。一般当前的返回值是根据下一个循环的返回值求得。

比如下面的等比计算
```go
func dengbi(start, num, step int) int {
	// 确定终止条件
	if num == 1  {
		return start
	}

	// 确定递归函数(即下一个循环)的参数和返回值
	next := dengbi(start,num - 1 ,step)

	// 确定单层递归的逻辑
	return  next * step
}
```

### 2、实现原理
递归的实现就是：**每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。**

相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是Segmentation fault（当然不是所有的Segmentation fault 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。

**在企业项目开发中，尽量不要使用递归！**在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）

### 3、递归和栈的关系
**栈其实就是递归的一种是实现结构。**

**所以：栈与递归之间在某种程度上是可以转换的！**

**用栈来实现递归的写法，也就是所谓的迭代法。**

##### a) 递归与迭代究竟谁优谁劣呢？
从时间复杂度上其实迭代法和递归法差不多（在不考虑函数调用开销和函数调用产生的堆栈开销），但是空间复杂度上，递归开销会大一些，因为递归需要系统堆栈存参数返回值等等。

递归更容易让程序员理解，但收敛不好，容易栈溢出。

这么说吧，递归是方便了程序员，难为了机器（各种保存参数，各种进栈出栈）。

## 七、时间轮算法

详见“算法方法-时间轮算法”

## 八、KMP算法

详见“算法方法-KMP算法”

## 九、逐渐趋近法
先给结果赋值一个值，然后通过不断循环尝试中，如果结果可能是这个值，则更新为该值。最终结果不断调整至最终结果。

比如各种找大小的题目中。

## todo
简短的代码看不出遍历的顺序，也看不出分析的逻辑，还会把必要的回溯的逻辑隐藏了，所以尽量按照原理分析一步一步来，写出来之后，再去优化代码。


剪枝优化

