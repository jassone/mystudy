## 回溯算法

**原理：枚举出所有的情况，所以也是一种暴力算法。**

## 一、什么是回溯法
回溯法也可以叫做回溯搜索法，它是一种搜索的方式。

在二叉树搜索中，有时会用到回溯(比如力扣100题)，例如二叉树：以为使用了递归。

**回溯是递归的副产品，只要有递归就会有回溯。**

回溯函数也就是递归函数，指的都是一个函数。

## 二、回溯法的效率
回溯法的性能如何呢，这里要和大家说清楚了，虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。

因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

那么既然回溯法并不高效为什么还要用它呢？

因为没得选，一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

此时大家应该好奇了，都什么问题，这么牛逼，只能暴力搜索。

## 三、回溯法解决的问题
回溯法，一般可以解决如下几种问题：

* 组合问题：N个数里面按一定规则找出k个数的集合
* 切割问题：一个字符串按一定规则有几种切割方式
* 子集问题：一个N个数的集合里有多少符合条件的子集
* 排列问题：N个数按一定规则全排列，有几种排列方式
* 棋盘问题：N皇后，解数独等等

##### a) 举例子
比如01背包问题，每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

## 四、如何理解回溯法
回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度。

递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

## 五、回溯法模板
### 1、回溯函数模板返回值以及参数
在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。

回溯算法中函数返回值一般为void。

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

回溯函数伪代码如下：

```c++
void backtracking(参数)
```

### 2、回溯函数终止条件
既然是树形结构，就知道遍历树形结构一定要有终止条件。

所以回溯也有要终止条件。

什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

```C++
if (终止条件) {
    存放结果;
    return;
}
```

### 3、回溯搜索的遍历过程
在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

![20210130173631174.png](https://pic.imgdb.cn/item/628cf2f9094754312942abf0.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！

回溯函数遍历过程伪代码如下：

```C++
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，回溯不断调整结果集。**这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：
```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); //递归
        回溯，撤销处理结果
        // ****注意:如果有if判断，最好将上面三步放到一个if里面****
    }
}
```
这份模板很重要，后面做回溯法的题目都靠它了！

### 4、从树形结构来分析
**树形上的深度优先遍历，就是回溯算法。**
* 状态：每一个节点表示了求解问题的不同阶段。
* 状态重置：深度优先遍历在回到上一层结点时需要状态重置。

状态变量
* 递归到第几层->depth (startIndex)
* 已经选了哪些元素->path (result)
* 布尔数组->used (表示当前元素是否在path里)-空间换时间

## 六、回溯问题种类

### 1、组合或分割问题
**组合问题和分割问题都是收集树的叶子节点。**

对于组合问题，什么时候需要startIndex呢？
* 如果是一个集合来求组合的话，就需要startIndex，例如：77题：组合问题！。

* 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17题：电话号码的字母组合。
todo注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我再讲解排列的时候就重点介绍。

###### a）复杂度
一般说道回溯算法的复杂度，都说是指数级别的时间复杂度。

* 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
* 空间复杂度：$O(n)$，和子集问题同理。

### 2、排列问题

###### a）复杂度
* 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：result.push_back(path)），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。
* 空间复杂度：$O(n)$，和子集问题同理。

### 3、子集问题
子集问题是找树的所有节点。(其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。)

###### a）复杂度
* 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
* 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。



## 七、相关wiki
* 回溯 https://www.programmercarl.com/0077.组合.html#

* 去重的两种写法的性能分析 https://www.programmercarl.com/回溯算法去重问题的另一种写法.html