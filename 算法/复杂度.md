## 复杂度
## 一、时间复杂度
### 1、究竟什么是时间复杂度
**时间复杂度就是用来方便开发者估算出程序的运行时间。**

我们该如何估计程序运行时间呢，**我们通常会估计算法的操作单元数量，来代表程序消耗的时间。** 这里我们默认CPU的每个单元运行消耗的时间都是相同的。

假设算法的问题规模为n，那么操作单元数量便用函数f(n)来表示。

随着数据规模n的增大，算法执行时间的增长率和f(n)的增长率相同，**这称作为算法的渐近时间复杂度，简称时间复杂度，记为 O(f(n))。**

### 2、什么是大O
算法导论给出的解释：**大O用来表示上界的，**当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

同样算法导论给出了例子：拿插入排序来说，插入排序的时间复杂度我们都说是O(n^2 )。

但是在数据本来有序的情况下时间复杂度是O(n)，也就对于所有输入情况来说，最坏是O(n^2 ) 的时间复杂度，所以称插入排序的时间复杂度为O(n^2 )。

同样的同理我们在看一下快速排序，都知道快速排序是O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是O(n^2) 的，严格从大O的定义来讲，快速排序的时间复杂度应该是O(n^2 )。

但是我们依然说快速排序是O(nlogn)的时间复杂度，这个就是业内的一个默认规定，我们这里说的O 代表的就是一般情况，不是严格的上界。

![v2-e519984c89d0a0ba_r.jpeg](https://pic.imgdb.cn/item/626e8058239250f7c5d1d0d6.jpg)

面试中面试官绝对不会针对快速排序的时间复杂度问题来讨论O的定义， 大家知道讨论的时间复杂度就是指一般情况下的时间复杂度就好了。

大家要对算法的时间复杂度有这样的一个概念。**就是同一个算法的时间复杂度不是一成不变的，和输入的数据形式依然有关系。**

我们主要关心的还是一般情况下的数据形式。**面试中说道算法的时间复杂度是多少指的都是一般情况。**

但是如果面试官和我们深入探讨一个算法的实现以及性能的时候 我们就要时刻想着 数据用例的不一样 时间复杂度也是不同的。

### 3、如何描述时间复杂度
这个图中我们可以看出 不同算法的时间复杂度 在不同数据输入规模下的差异。

![3604f8947e_1440w.jpeg](https://pic.imgdb.cn/item/626e80c1239250f7c5d2d928.jpg)

我们在决定使用那些算法的时候 ，不是时间复杂越低的越好，要考虑数据规模，如果数据规模很小 甚至可以用O(n^2 )的算法比 O(n)的更合适。

就像上图中图中 O(5n^2 ) 和 O(100n) 在n为20之前 很明显 O(5n^2 )是更优的，所花费的时间也是最少的。

**那我们为什么在计算时间复杂度的时候要忽略常数项系数呢，**也就说O(100n) 就是O(n)的时间复杂度，O(5n^2 ) 就是O(n^2 )的时间复杂度。而且要默认O(n) 优于O(n^2 ) 呢 ？这里就又涉及到大O的定义。

**因为大O其实就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个点也就是 常数项系数已经不起决定性作用的点。**

例如上图中 20 就是那个点 ，n只要大于20 常数项系数已经不起决定性作用了。

所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下我们都是默认数据规模足够的大，基于这样的事实 我们给出的算法时间复杂的的一个排行如下所示：

**O(1)常数阶 < O(logn)对数阶 < O(n)线性阶 < O(n^2)平方阶 < O(n^3)(立方阶) < O(2^n) (指数阶)**

### 4、你所不知道的O(logn)
我们平时说这个算法的时间复杂度是logn的，一定是log 以2为底n的对数么？

其实不然，也可以是以10为底n的对数，也可以是以20为底n的对数，但我们统一说 logn，也就是忽略底数的描述。

如下图所示：
![v2-890e7d5ac40w.jpeg](https://pic.imgdb.cn/item/626e816c239250f7c5d491b0.jpg)

假如我们有两个算法的时间复杂度 分别是log以2为底n的对数 和 log 以10为底n的对数

那么这里如果大家还记得我们高中数学的话，应该不能理解 **以2为底n的对数 = 以2为底10的对数 乘以 以10为底n的对数。**

那这里以2为底10的对数 是一个常数，而我在上面已经讲述了我们计算时间复杂度是忽略常数项系数的。

抽象一下 log 以i为底n的对数 等于 log 以j为底n的对数，所以我们忽略了i，直接说是logn，正式因为logij 是就一个常数。

### 5、如果时间复杂度是一个复杂的表达式，我们如何简化
有时候，我们去计算时间复杂度的时候 发现不是一个 简单的O(n) 或者O(n^2)， 而是一个复杂的表达式，例如：

O(2\*n^2 + 10*n + 1000)

那这里我们通常如何描述这个算法的时间复杂度呢，一种方法就是简化法

去掉运行时间中的加法常数项 （因为常数项并不会因为n的增大而增加计算机的操作次数）

O(2\*n^2 + 10*n)

去掉常数系数 （我们刚刚已经详细讲过为什么可以去掉常数项的原因了）

O(n^2 + n)

只保留保留最高项 去掉数量级小一级的n （因为n^2 的数据规模远大于 n），最终简化为：

O(n^2 )

如果这一步同学们理解有困难，那也可以做提取n的操作，变成O(n(n+1)) ，省略加法常数项后 也别变成了

O(n^2 )

所以最后我们说：我们这个算法的算法时间复杂度是 O(n^2 ) 。

也可以用另一种简化的思路，当n大于40的时候 ， 这个复杂度 会一直小于O(3*n^2 )

O(2\*n^2 + 10\*n + 1000) < O(3*n^2)

所以说 最后我们省略掉常数项系数最终时间复杂度也是O(n^2)。

### 6、举例说明时间复杂度要怎么算
题目描述：找出n个字符串中相同的两个字符串（假设这里只有两个相同的字符串）

一些同学可能以为解决这道题目可以采用枚举遍历的解法，时间复杂度是O(n^2 )。

这个时间复杂度其实是不对的。

这里一些同学忽略了字符串比较的时间消耗，这里并不像int 型数字做比较那么简单。

**除了n^2 次的遍历次数外， 字符串比较依然要消耗m次操作（m也就是字母串的长度），所以时间复杂度是O(m\*n*n)。**

那么我们再想一下其他解题思路。我们先排对n个字符串按字典序来排序，排序后n个字符串就是有序的，意味着两个相同的字符串就是挨在一起。

然后在遍历一遍n个字符串，这样就找到两个相同的字符串了。

那我们来看看这种算法的时间复杂度

快速排序时间复杂度 为O(nlogn)，依然要考虑字符串的长度是m，那么快速排序每次的比较都要有m次的字符比较的操作，就是O(m\*n*logn)。

之后我们还要遍历一遍这n个字符串找出两个相同的字符串，别忘了遍历的时候依然要比较字符串，所以总共的时间复杂度是 O(m\*n\*logn + n*m)。

我们对O(m\*n\*logn + n\*m) 进行简化操作，把m\*n提取出来变成O(m\*n*(logn + 1))。

在省略常数项最后的时间复杂度是 O(m\*n\*logn)， 那我们比较一下时间效率O(m\*n\*logn) 是不是比第一种方法O(m\*n*n)更快一些呢。

所以 先把字符串集合排序在遍历一遍找到两个相同字符串的方式要比直接暴力枚举的方式更快。

### 7、字符串操作时的时间复杂度
比如字符串对比，有字符串s1和s2，假设字符串最长为s，则为O(n)。

## 二、空间复杂度
### 1、定义
**全称是 渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。**

一个程序的空间复杂度是指运行完一个程序所需**内存的大小**。利用程序的空间复杂度，可以对程序的运行所需的内存有个预先估计。

程序执行时所需存储空间包括以下两部分：
* 固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。

* 可变空间。这部分空间主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。

我们在写代码时，完全可以用**空间来换取时间**，比如字典树、哈希等都是这个原理。他们都是O(1)的时间复杂度。

### 2、几种类型说明
##### a) 空间复杂度为O(1)
常量空间:有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地”或者“原地”执行的，是节省存储的算法，空间复杂度为O(1)。

##### b)空间复杂度为O(n)
线性空间:有的算法需要占用的临时工作单元与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况。

**递归的空间复杂度也是线性的**：递归过程就是一个进栈和出栈的过程，当进入一个新函数时，进行入栈操作，把调用的函数和参数信息压入栈中；当函数返回时，执行出栈。如果递归的深度是n，那么空间复杂度就是O(n)。

##### c) 空间复杂度为O(n^2 )/O（nm)
二维空间：算法中定义了一个二维列表集合，并且集合的长和宽都和输入规模n成正比。

### 3、常见的空间复杂度
比如O(1)、O(n)、O(n^2 )，像是O(logn)、O(nlogn)对数阶的复杂度平时都用不到，而且空间复杂度分析比时间复杂度分析要简单很多。


 