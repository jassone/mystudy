## 数组和链表的对比

## 一、数组的特点
数组在计算机底层里，是一块儿**连续的内存**。所以一个长度为n的数组需要一次性申请长度为n的一块儿内存。

- 数组在插入删除时会造成指针挪移，也正是这个特点让他具有了随机访问的特性。所以数组有一个O(n)的指针挪移。
- 动态数组增删某个节点后，其后的结点位置会更改。

- 长度为n的数组要插一位扩容成长度为n+1的数组，理论上是需要重新申请一段长n+1的内存，然后把之前的n位拷贝过去，再把新插入的一位放在指定位置，复杂度是O(n)。但是数组多了重新申请内存的消耗。


优化点：一开始就申请大一点数组，以免重新申请内存。

### 1、数组插入一个元素的情况
* 有一个O(n)的查找操作(虽然说数组基于下标查找元素是O(1)的复杂度，但底层还是得变量数组，找到目标索引)。
* 然后有一个O(1)的插入操作。
* 最后还需要有一个O(n)的调整操作，保证内存连续。

复杂度：O(n)+O(1)+O(n)

但是数组的下标访问是通过内存地址运算得来的，公式为a[i]_address = base_address + i * data_type_size，所以数组的第一个O（n）实际上还是O（1），也就是通过数组下标偏移量可以直接常量级时间找到目标元素。

所以复杂度应该为: O(1)+O(1)+O(n)

### 2、数组扩容的情况
在数组插入一个数组的前提下，还需要
* 旧数组到新数组的拷贝过程是O(n)
* 还要申请N倍的新内存空间

## 二、链表的特点
链表无所谓连续，一般可以认为一个长度为n的链表是n段儿长度为1的内存。因此当需要插入一个新元素的时候，对于链表只需要再申请一个长度为1的内存，然后用一个O(n)的操作找到位置，插进去。

删除时，只需要用一个O(n)的操作找到位置，删除节点。

### 1、链表插入一个元素的情况
* 有一个O(n)的查找操作
* 然后有一个O(1)的插入操作

复杂度：O(n)+O(1)

### 2、链表扩容的情况
同链表中插入一个元素

## 三、整体对比

### 1、链表优势
链表擅长写入。

* 链表相比数组(线性表)，最大的优势是扩容成本低。

* 在小于1/2位置插入时，链表更快(链表头部查找耗时是少点)，在大于1/2位置时，数组更快(数组的挪到少点)。 

### 2、数组优势
数组擅长读取。

* 数组最大的优势就是可以直接应用二分查找算法(前提是有序)寻找插入位置实现元素的有序存储，而且随机访问速度(包括点查询和范围查询)更是吊打链表。

* 遍历速度数组也比链表快，因为数组是连续的一块内存能充分利用CPU高速缓存(TLB Hit)，而链表虽然逻辑上是连续的，但在内存存储上不是连续的，而是离散的。


在写入场景中，数组和链表的复杂度是定位和写入复杂度之和，都是O(n)，但写入比定位的O(n)慢很多，所以两个表面看起来一样的O(n)的实际时间还是差很多，所以说链表和数组的插入删除时间复杂度都是o(n)，链表写入效率高。


如果你要在链表中删除某个元素，你首先得找到它啊！这个链表的查找可耗时的呀！

所以说对于链表的插入操作，不能只关注其插入的时间复杂度，也要算上查找到前节点的开销，因此不能武断地说：频繁增删的情况下，用链表比较合适