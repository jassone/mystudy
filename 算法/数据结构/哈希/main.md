## hash 
哈希表是一种根据关键字key来访问值value的一种数据结构。

哈希表的本质是**数组加哈希函数**。数组不难理解，那什么是哈希函数？

### 1、原理简介
在哈希表中，它的作用就是将哈希表的某个key作为输入，然后经过一系列的运算后，得到数组的某个索引。一种很朴素的思路是，先用key计算出一个很大的数，然后对数组长度取模，从而得到索引，这只是众多方法中的一种，其他的比如：直接寻址法，平方取中法等。

得到索引后就可以通过索引对数组执行插入或查找的操作，因为**本质上是通过索引来访问数组**，所以哈希表的插入和查找的效率非常高，时间复杂度都是O(1)。

![82859b5e94ee7bb4.jpeg](https://pic.imgdb.cn/item/6272868c0947543129bc9bc5.jpg)

### 2、作用
那么哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里**。

## 一、hash函数
比如把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

比如通过hash函数把名字转化为数值，一般hash函数是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。

### 1、如果hash函数得到的数值大于哈希表的大小。
也就是大于tableSize了，怎么办呢？

此时为了保证映射出来的索引数值都落在哈希表上，我们会再次对数值做一个取模的操作，就要我们就保证了学生姓名一定可以映射到哈希表上了。

此时问题又来了，哈希表我们刚刚说过，就是一个数组。如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置，这就是hash碰撞了。

所以一个好的哈希函数必须要求尽量减少冲突发生的概率，也就是要求数据分布尽量均匀。

## 二、hash函数散列方法
在哈希表长度一定的情况下，数据分布均匀的目标是通过**哈希算法（散列方法）**实现的。

### 1、除法散列法 
公式： index =hashcode % length

但是由于位运算速度远快于求模运算，所以一般使用按位与运算进行求模，公式为：index = hashcode &(length-1)。不过这种方法要求length必须为2的整数次方时，两个公式才相等。因为当length为2的整数次方时，length-1的二进制表示全部为1，所以跟hashcode进行按位与运算可以得到槽索引，范围为[0,length)。

### 2、平方散列法 
求index是非常频繁的操作，而乘法的运算要比除法来得省时，所以我们考虑把除法换成乘法和一个位移操作。公式： 

index = (hashcode * hashcode) >> 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除）

这种方法如果hashcode值不大的话，其平方值也不会很大，那么其二进制高位几乎全为0。最后经过位移运算的结果肯定为0。那么hashcode不大的情况下，全部得到索引号为0，这种冲突显然不想看到。所以要求hashcode必须足够大。

### 3、斐波那契（Fibonacci）散列法
平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿hashcode本身当作乘数呢？答案是肯定的。

* 对于16位整数而言，这个乘数是40503。
* 对于32位整数而言，这个乘数是2654435769。
* 对于64位整数而言，这个乘数是11400714819323198485。

这几个“理想乘数”是如何得出来的呢？**这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，**即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34，…。是不是觉得很神奇，可能这就是数学之美吧。

如果是16位整数，则公式变为
index = (value * 40503) >> 28

通过采用适当的散列方法，我们可以控制数据尽量均匀地分布在槽中。

## 三、hash冲突
我们不难发现哈希函数是整个哈希表的关键。所以为了更好的性能，我们希望在尽可能短的时间内，相同的key经过哈希函数的计算，可以得到相同的索引，不同的key经过哈希函数的计算，可以得到不同的索引，但在实际中往往事与愿违，**不同的key小概率会计算出相同的索引，这就是哈希冲突（collision）**，几乎所有的哈希函数都存在这个问题。

这里介绍几个常见的解决哈希冲突的方法。

### 1、开放寻址法
**开放寻址是一种思想，如果通过哈希函数计算出的索引所对应的空间已经被占用了，就再找一个还没被占用的空间将数据存进去。**

##### a) 线性探测法
简单来说就是从当前被占用的空间的索引开始，向下遍历整个数组，直到找到空闲空间为止。如下图所示：
![ab1735af047aec9086.jpeg](https://pic.imgdb.cn/item/62728bfb0947543129ccc56d.jpg)

##### b）双重哈希法
使用多个哈希函数来计算索引，如果第一个哈希函数计算得到的索引所对应的空间已被占用，就用第二个，第二个被占用就用第三个，以此类推，直到计数出没被占用的空间对应的索引。

### 2、链表法/链地址法
**链表法是一种更加常见的解决哈希冲突的方法**，Java中的HashMap就是采用这种方法。在这种方法中，数组索引对应的空间并不直接存储数据，而是存储一个链表的地址，而数据存在链表中。如下图所示：
![b1dea4168601e49f.jpeg](https://pic.imgdb.cn/item/62728c5f0947543129cdf3e8.jpg)

这样发生冲突时，就可将冲突的key对应的数据存在同一个链表上，当需要取数据时，就先找到key对应的链表，然后遍历链表。

## 四、负载因子和再哈希
如果一个哈希表被创建了，刚开始所有的槽都是空的。这时候传入一部分数据，数据通过哈希函数应该是可以均匀分布在数组的各个槽中的。偶尔会有小概率的数据发生冲突，被存储在同一个链表中，问题不大。但是随着数据的增多，空槽的数量越来越少，发生冲突的概率越来越大。为了解决这个问题，我们引入了负载因子和再哈希的概念。

### 1、再哈希
**指的是当槽的利用率（已使用槽与总槽数的比值）达到负载因子时，哈希表会就地扩容，具体过程为调用resize()方法，将哈希表的容量变为原来的两倍。之后对所有的数据重新进行散列过程，存储到相应的位置。**

### 2、什么时候再哈希（给数组扩容)
**装载因子/负载因子（已插入元素的数量除以数组容量）超过某一阈值时就进行扩容**，Java中HashMap的装载因子是0.75，当然，也可以是别的值。因为之前插入的元素都是按照原数组的长度来计算索引的，所以一旦数组扩容后，长度改变，就要重新进行计算，然后将已插入的元素移动到新的位置上，所以数组扩容不仅仅只是将容量增大而已。
![![](https://pic.imgdb.cn/item/62728d0e0947543129cfed0e.jpg)

### 3、再哈希发生的阈值的设置。
要注意的是，再哈希的工作量是很大的，因为要对所有数据进行散列过程。所以，哈希表的长度和负载因子选取要合适。在负载因子一定的情况下，如果长度过小，再哈希就会频繁发生，这会严重影响性能；如果长度设置过大，虽然再哈希发生的频率很低，但是会浪费空间。同理，负载因子如果选取过大，那么在再哈希发生之前，就会产生大量的冲突（因为槽位基本已满）；如果负载因子选取过小，那么再哈希就会频繁发生，也会影响性能。**一般默认长度为16，负载因子为0.75。**

## 五、哈希表查找过程
当使用哈希表进行查询的时候，**就是再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，**如此一来，就可以充分利用到数组的定位性能进行数据定位。

## 六、常见的哈希结构
当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。
**重要重要重要**
* 数组
* set （集合）
* map(映射)

看下C++中的情况

|类型|底层实现|是否有序|数值是否可以重|能否更改数值|查询效率|增删效率| 
|---|---|---|---|---|---|---| 
|std::set|红黑树|有序|否|否|O(logn)|O(logn)|
|std::map|红黑树|key有序|key不可重复|key不可修改|O(logn)|O(logn)|

## 七、应用场景
|场景|说明|
|---|---|
|关联数组|哈希表通常用于实现许多类型的内存表。它们用于实现关联数组（索引是任意字符串或其他复杂对象的数组）|
|数据库索引|哈希表也可以用作基于磁盘的数据结构和数据库索引（例如在dbm中）。|
|高速缓存|哈希表可用于实现高速缓存，即用于加速对数据的访问的辅助数据表，其主要存储在较慢的介质中。|
|对象表示|	一些动态语言（如Perl，Python，JavaScript和Ruby）使用哈希表来实现对象。|
|提升速度|哈希函数用于各种算法，以使其计算更快。|
|键分配地址|比如取模法，与运算。|

## 八、相关wiki
* todo 算法链接
