## 链表
链表是一种非内存连续的数据，其优点是通过改变指针地址来快速增减元素。很明显的问题，你首先要知道你要增加/删除的目标元素是哪个! 所以会浪费 `O(n)` 的查询时间。

链表按照不同的连接结构可以划分为单链表、循环链表和双向链表。

**链表增删性能罪魁祸首就是查找操作，对于查找操作，效率最高的莫过于二分查找了。**但是对于第一个有序链表中是无法使用二分查找的。

## 一、单链表
单链表是一种顺序存储的结构。 

每个结点包含了两个域：
* 一个是存储数据元素的数据域（信息域）
* 一个是存储下一个结点地址的指针域

有一个头结点，**没有值域，只有连域**，专门存放第一个结点的地址。 

有一个尾结点，有值域，也有链域，**链域值始终为NULL**。 

**所以，在单链表中为找第i个结点或数据元素，必须先找到第i - 1 结点或数据元素，而且必须知道头结点，否者整个链表无法访问。**

性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。

## 二、单向循环链表
* 初始化时，头节点的next指向自己。
* 除了尾节点的后继指针指向首节点的地址外均与单链表一致。
* 适用于存储有循环特点的数据，比如约瑟夫问题。

## 三、双向链表
* **节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）**
* **首节点的前驱指针prev和尾节点的后继指针均指向空地址。**

    双向链表相较于单链表的一大优势在于：找到前驱节点的时间复杂度为O(1)，而单链表只能从头节点慢慢往下找，所以仍然是O(n)。而且，对于插入和删除也是有优化的。

## 四、双向循环链表
将双向表和循环表整合一起。

## 五、区分逻辑上的链表和代码中的链表
### 1、逻辑上的链表
a->b->c->nil

是为了帮助分析，所以简化了一些。

### 2、代码中的链表
head->a->b->c->nil
代码里，只有被一个变量指向、保存的链表，才有意义。

我们对链表进行添加节点、删除节点，最终都要体现在链表的表示上。

比如head->a->b->c->d->nil中，在a前面添加一个e，逻辑上处理完后就是e->a->b->c->d->nil，但是还要增加一个头结点的处理，即head->e->a->b->c->d->nil。

## 六、解题常用关键技巧
### 1、虚拟头结点/哑节点的使用

## 七、相关问题
### 1、单链表删除一个元素，且时间复杂度是O(1)
问题描述：
给定一个单链表中的一个等待被删除的节点。请在在O(1)时间复杂度删除该链表节点。

##### a) 非表头或表尾
思路：**，使要删除的节点之后的节点覆盖前一个节点即可。**
node->val=node->next->val;
node->next=node->next->next;

##### b）要删除的结点在末尾，怎么处理？
那么此种特殊情况，还是需要从头到尾遍历整个链表，得到该结点的前驱，然后删除该结点。

##### c) 只有一个结点，那么删除该结点需要做什么处理？
如果单链表只有一个结点，现在需要删除这个结点，也就是链表的头结点（尾结点），那么在删除之后，需要把头指针指向 NULL处理。

##### d) 时间复杂度分析
如果是删除非末位的结点，且结点有n（n>1）个，那么时间复杂度是 o（1），对于尾结点，是 o（n），总得来说，是【（n-1）o（1）+o（n）】/ n，结果还是 o（1），复合要求。

## 六、链表优化
对链表建立索引，用树状索引或者哈希索引，通过索引查找就不是O(n)了。

跳表优化索引呢？todo

## 应用
LRU缓存策略的实现，这是非常典型的链表的应用。 todo

## 相关wiki
* 进入大厂不困难之链表 https://zhuanlan.zhihu.com/p/428399243