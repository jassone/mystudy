## 二叉树
## 一、二叉树特性
### 1、高度和深度
* 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
* 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。

但leetcode中强调的深度和高度很明显是按照节点来计算的，如图：
![20210203155515650.png](https://pic.imgdb.cn/item/628ba40409475431296c41f0.png)

关于根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0，我们暂时以leetcode为准（毕竟要在这上面刷题）。

## 二、二叉树的种类
### 1、满二叉树
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
![20200806185805576.png](https://pic.imgdb.cn/item/628459c40947543129888396.png)

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

### 2、完全二叉树
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

举一个典型的例子如题：
![20200920221638903.png](https://pic.imgdb.cn/item/6284eddf09475431298d5b50.png)

### 3、二叉搜索树
前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树
![20200806190304693.png](https://pic.imgdb.cn/item/6284f07c09475431298fdb14.png)

### 4、平衡二叉搜索树(AVL树)
平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：
**它是一棵空树或任何节点的两个子树的高度最大差为1，并且左右两个子树都是一棵平衡二叉树。**
![20200806190511967.png](https://pic.imgdb.cn/item/6284f1a2094754312990f2ff.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

又如下图，右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1； 
![20220209174848.jpg](https://pic.imgdb.cn/item/62038e0b2ab3f51d9127f2cb.jpg)

如果在AVL树中进行插入或删除节点，可能导致AVL树失去平衡，这种失去平衡的二叉树可以概括为四种姿态：LL（左左）、RR（右右）、LR（左右）、RL（右左）。它们的示意图如下：
![20220209180259.jpg](https://pic.imgdb.cn/item/6203915f2ab3f51d912aff39.jpg)

AVL树失去平衡之后，可以通过旋转使其恢复平衡。

##### a） 缺点：
* 原理复杂，增删操作，都需要其依靠平衡操作引发子树的调整。
* 随着树高度增加，查找越慢(磁盘IO次数增加)
* 回旋查找大于某个数时，如果结果很大，会有很多回旋，很慢。


### 5、多叉平衡查找树（B-Tree）
B 树是为了磁盘或其它存储设备而设计的一种多叉平衡查找树（相对于二叉，B树每个内结点有多个分支，即多叉，不是二叉的）。B树主要应用于文件系统以及部分数据库索引，如MongoDB。

B树又可以写成B-树/B-Tree，并不是B“减”树，横杠为连接符，容易被误导。

B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。

一棵m阶的B-Tree有如下特性： 
1. 每个节点最多有m个孩子。 
2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
3. 若根节点不是叶子节点，则至少有2个孩子 
4. 所有叶子节点都在同一层，且不包含其它关键字信息 
5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
7. ki(i=1,…n)为关键字，且关键字升序排序。 
8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)

B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 
![20220210100335.jpg](https://pic.imgdb.cn/item/620472832ab3f51d91d6be05.jpg)
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。

模拟查找关键字29的过程：
1. 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
2. 比较关键字29在区间（17,35），找到磁盘块1的指针P2。
3. 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
4. 比较关键字29在区间（26,30），找到磁盘块3的指针P2。
5. 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
6. 在磁盘块8中的关键字列表中找到关键字29。

分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。**由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率**。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。**B-Tree相对于AVLTree缩减了节点个数**，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。

##### a）特点
* B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题。
* 插入或者删除元素都会导致节点发生裂变反应，有时候会非常麻烦，但正因为如此才让B树能够始终保持多路平衡，这也是B树自身的一个优势：自平衡。

##### b）为什么索引是使用B-Tree而不是二叉查找树
**关键因素是磁盘IO的次数。**

数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。

从二叉树的查找过程了来看，最坏的情况下磁盘IO的次数由树的高度来决定。减少磁盘IO的次数就必须要压缩树的高度，让瘦高的树尽量变成矮胖的树，所以B-Tree就在这样伟大的时代背景下诞生了。

从查找过程中发现，B树的比对次数和磁盘IO的次数与二叉树相差不了多少，那么B树的优势在哪呢？

* 比对是在内存中完成中，不涉及到磁盘IO，耗时可以忽略不计。另外B树种一个节点中可以存放很多的key（个数由树阶决定）。

* 相同数量的key在B树中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。

### 6、B+Tree
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。

从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。

在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

B+Tree相对于B-Tree有几点不同：
1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有一个链指针。
3. 数据记录都存放在叶子节点中。

将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：
![20220210104431.jpg](https://pic.imgdb.cn/item/62047c192ab3f51d91dfb6f7.jpg)

通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。

可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

## 二、二叉树的存储方式
二叉树可以顺序存储，也可以链式存储。

* 顺序存储的方式就是用数组。
* 链式存储方式就用指针。

顾名思义就是
* 顺序存储的元素在内存是连续分布的。
* 而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。

### 1、链式存储
链式存储是大家很熟悉的一种方式。
![2020092019554618.png](https://pic.imgdb.cn/item/6284f2c8094754312991b13b.png)

### 2、顺序存储
其实就是用数组来存储二叉树。
![20200920200429452.png](https://pic.imgdb.cn/item/6284f40b094754312992705a.png)

用数组来存储二叉树如何遍历的呢？
**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

所以要注意，用数组依然可以表示二叉树。

## 三、二叉树的遍历方式
二叉树主要有两种遍历方式：
* 深度优先遍历：先往深走，遇到叶子节点再往回走。
* 广度优先遍历：一层一层的去遍历。

这两种遍历是图论中最基本的两种遍历方式。

### 1、深度优先遍历
包括
* 前序遍历（递归法，迭代法）
* 中序遍历（递归法，迭代法）
* 后序遍历（递归法，迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历。**其实指的就是中间节点的遍历顺序。**

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式：
* 前序遍历：中左右
* 中序遍历：左中右
* 后序遍历：左右中
![20200806191109896.png](https://pic.imgdb.cn/item/6284f770094754312994736f.png)

在做二叉树相关题目，经常会使用**递归**的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

### 2、广度优先遍历
包括
* 层次遍历（迭代法）

广度优先遍历的实现一般使用**队列**来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

**二叉树的层序遍历，就是图论中的广度优先搜索在二叉树中的应用，需要借助队列来实现（此时又发现队列的一个应用了）。**

层序遍历遍历相对容易一些，只要掌握基本写法（也就是框架模板），剩下的就是在二叉树每一行遍历的时候做做逻辑修改。

## 四、二叉搜索树查找
**二叉搜索树查找查询的时间复杂度是O（logN）。**

二叉搜索树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。 
如下图所示就是一棵二叉查找树，
![20220209173858.jpg](https://pic.imgdb.cn/item/62038cfb2ab3f51d91270aa5.jpg)

对该二叉搜索树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次

二叉搜索树可以任意地构造，同样是2,3,5,6,7,8这六个数字，也可以按照下图的方式来构造：
![20220209174003.jpg](https://pic.imgdb.cn/item/62038d2b2ab3f51d91273718.jpg)

但是这棵二叉树的查询效率就低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉搜索树(AVL树)。

## 五、二叉树定义
比如go中
```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```

## 六、其他
### 1、二叉树家族演化
二叉树 -> 平衡二叉树（AVLTree）-> 多叉平衡查找树（B-Tree）-> B+Tree

### 2、参考wiki
* BTree和B+Tree详解 https://www.cnblogs.com/vianzhang/p/7922426.html


