## 高性能IO设计模式

在传统的网络服务设计模式中，有两种比较经典的模式：一种是多线程，一种是线程池。

## 一、多线程

对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：

![TS5qcGc.png](https://pic.imgdb.cn/item/62ddfa2df54cd3f9370a971f.png)

这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式。

## 二、线程池

先创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。

因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。

## 三、高性能IO设计模式：Reactor和Proactor

不同的操作系统实现的io策略可能不一样，即使是同一个操作系统也可能存在多重io策略，常见如linux上的select，poll，epoll，面对这么多不同类型的io接口，这里需要一层抽象api来完成，所以就演变出来两种高性能的io的设计模式，分别是Reactor（同步IO）和Proactor（异步IO）。

## 四、Reactor模型

在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：

![NDZnTS5qcGc.png](https://pic.imgdb.cn/item/62ddfb30f54cd3f9370e81fa.png)

从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。

## 四、Proactor模型

在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。



