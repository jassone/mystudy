## 高性能IO设计模式

在传统的网络服务设计模式中，有两种比较经典的模式：一种是多线程，一种是线程池。

## 一、多线程

对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：

![TS5qcGc.png](https://pic.imgdb.cn/item/62ddfa2df54cd3f9370a971f.png)

这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式。

## 二、线程池

先创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。

因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。

## 三、高性能IO设计模式：Reactor(响应器模式)和Proactor(前摄器模式)

不同的操作系统实现的io策略可能不一样，即使是同一个操作系统也可能存在多重io策略，常见如linux上的select，poll，epoll，面对这么多不同类型的io接口，这里需要一层抽象api来完成，所以就演变出来两种高性能的io的设计模式，分别是Reactor（同步IO）和Proactor（异步IO）。

## 四、Reactor模型

在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：

![NDZnTS5qcGc.png](https://pic.imgdb.cn/item/62ddfb30f54cd3f9370e81fa.png)

从这里可以看出，多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。

大致流程：在Reactor中，事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。

Reactor 的标准（典型）的工作方式是：

1. 应用程序注册读就绪事件和相关联的事件处理器
2. Reactor阻塞等待内核事件通知
3. Reactor收到通知，然后分发可读写事件（读写准备就绪）到用户事件处理函数
4. 用户读取数据，并处理数据
5. 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

优点：

- 并发系统常使用reactor模式，代替常用的多线程的处理方式，节省系统的资源，提高系统的吞吐量。

### 1、一些细节部分

I/O 多路复用技术会用一个系统调用函数来监听我们所有关心的连接，也就说可以在一个监控线程里面监控很多的连接。
我们熟悉的 select/poll/epoll 就是内核提供给用户态的多路复用系统调用，线程可以通过一个系统调用函数从内核中获取多个事件。

##### 当下开源软件能做到网络高性能的原因就是 I/O 多路复用吗？

是的，基本是基于 I/O 多路复用。

于是，大佬们基于面向对象的思想，对 I/O 多路复用作了一层封装，让使用者不用考虑底层网络 API 的细节，只需要关注应用代码的编写。

大佬们还为这种模式取了个让人第一时间难以理解的名字：Reactor 模式。

多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：

- 主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。
- 主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。

## 四、Proactor模型

在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。

![1980722496.png](https://pic.imgdb.cn/item/62de6650f54cd3f9373b8901.png)

Proactor 的标准（典型）的工作方式是：

1. 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。
2. 事件分离器等待读取操作完成事件
3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。
4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

## 五、Reactor和Proactor的区别

| 区别       | Reactor                                                      | Proactor                                                     |
| ---------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 定义       | 被动的等待指示事件的到来，并作出反应。它有一个等待的过程，做什么事都要放入到监听事件集合中等待handler可用时再操作。 | 直接调用异步读写操作，调用完立即返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑。 |
| 实现       | 实现了一个被动的事件分离和分发模型服务等待请求事件的到来，再通过不间断地同步处理事件做出反应。 | 实现了一个主动的事件分离和分发模型。允许多个任务并发的执行，从而提高吞吐量，可执行耗时长的任务。 |
| 主动与被动 | 被动                                                         | 主动                                                         |
| 同步与异步 | 同步                                                         | 异步                                                         |
| 优点       | 1. 简单。实现相对简单，对于耗时短的处理场景处理高效。2. 单线程。操作系统可在多个事件源上等待。避免了多线程编程相关的性能开销和编程复杂性。3. 不用锁。事件的串行化对应用时透明的，可以顺序的同步执行而不需加锁。4. 事务隔离。将与应用无关的  多路分解和分配机制 与应用相关的  回调函数 分离开来 | 性能更高，能够处理耗时长的并发场景。                         |
| 缺点       | 处理耗时长的操作会造成事务分发的阻塞，影响后续事件的处理。   | 1. 复杂。实现逻辑复杂。2. 依赖OS对异步的支持（很少很难）     |
| 使用场景   | 同时接受多个服务请求，并且依次同步的处理他们的事件驱动程序。耗时短的。 | 异步接受和同时处理多个服务请求的事件驱动程序耗时长的。       |

## 六、各种IO架构的简单的理解

以一个餐饮为例，每一个人来就餐就是一个事件，他会先看一下菜单，然后点餐。就像一个网站会有很多的请求，要求服务器做一些事情。处理这些就餐事件的就需要我们的服务人员了。

### 1、在多线程处理的方式会是这样的：

一个人来就餐，一个服务员去服务，然后客人会看菜单，点菜。 服务员将菜单给后厨。

二个人来就餐，二个服务员去服务……

五个人来就餐，五个服务员去服务…

### 2、在线程池处理的方式会是这样的：

固定的10个人去服务，但仍然供不应求。

### 3、Reactor设计模式: 单个线程来做多线程的事

顾客通过呼叫服务员（event事件）通知服务员，菜单写好了，服务员就会把菜单交给厨师（事件处理器），厨师就会去做菜了。

![690367925.png](https://pic.imgdb.cn/item/62de65e6f54cd3f937397933.png)

### 4、Proactor设计模式: 让别人做完通知自己

![143897891.png](https://pic.imgdb.cn/item/62de66bef54cd3f9373d9345.png)

## 七、相关wiki

- 高性能 I/O Reactor设计模式 https://zhuanlan.zhihu.com/p/474359473 
- 高性能网络框架：Reactor 和 Proactor   非常经典： https://bbs.huaweicloud.com/blogs/266248 todo