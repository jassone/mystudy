## 进程线程协程
## 一、进程
进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行**资源分配管理最小单位/基本单位**，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

### 1、特点
* 从程序角度来说静态的，还没开始运行程序。
* 程序进入内存，分配对应资源，内存空间，进程进入内存，同时产生一个主线程。

### 2、进程组成

进程一般由程序、数据集合和进程控制块三部分组成。
* 程序：用于描述进程要完成的功能，是控制进程执行的指令集；
* 数据集合：是程序在执行时所需要的数据和工作区；
* 程序控制块：(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。

### 3、进程具有的特征：
* 动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；
* 并发性：任何进程都可以同其他进程一起并发执行；
* 独立性：进程是系统进行资源分配和调度的一个独立单位；
* 结构性：进程由程序、数据和进程控制块三部分组成。
* 隔离性: 进程资源和其他进程不共享。

### 4、为什么要多进程

##### a) 多进程主要用在c/c++开发中，利用linux原生的多进程通信机制IPC（Interproces Communication）来实现，比如共享内存，管道...

* 在java中全是单进程多线程程序。

* 开多个进程，通过本地socket通信，这个不算是‘多进程’程序，而是相当于多台机器(多个进程)的分布式系统。

##### b) 随着云原生的兴起，‘多进程程序’越来越少，除非特别必要的场景，比如Agent,ServerMesh

* 通过共享内存通信的多进程程序，需要多个容器之间共享内存通信，部署麻烦。

* 能用多进程解决的问题，往往都可以用多线程解决。

##### c) 那么为什么以前做c/c++开发开发，经常用多进程？
为了简单，把1个机器的多个核当成多台机器，每个核上一个进程，彼此之间独立不通信，省去了多线程之间复杂的通信、同步机制。

## 二、线程
在早期的操作系统中并没有线程的概念，它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。

后来，由于进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。

线程是程序执行中一个**单一的顺序控制流程，是计算机运行(程序执行流)的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)**。

* 一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。

* **一个进程至少有一个主线程，比如main()函数就是一个主线程。**

应用：
* go  routine 轻量级的线程，是程序员层的行为。

### 1、特点
* 动态的，程序真正开始运行了
* 操作系统的线程才是真的线程，程序员写的代码，开启了线程也只能挂靠到操作系统上的线程去执行。
* 线程:CPU核 = 1:1，一个时间点只有一个线程被放进cpu执行。
* 同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)。
* 某进程内的线程在其它进程不可见。

### 2、优点
* 提高CPU利用率，提高并发

### 3、缺点
* 线程之间切换会有上下文切换，比如记住现场，执行到哪里，需要哪些数据等，高并发中有性能开销。
* 线程频繁创建销毁会带来严重的性能问题，
* 线程之间会有竞争，数据同步需要用锁等机制确保数据的一直性和可见性。

### 4、线程实现方式
##### a) LWP作为多线程方案(linux多线程方案）

![20220225141529.jpg](https://pic.imgdb.cn/item/6218740d2ab3f51d9154f94b.jpg)
一个用户线程对应一个LWP,而一个LWP对应一个内核调度体。

优点
* 真正实现并行操作
* 克服阻塞问题

缺点
* 控制转移开销大
* 调度算法由操作系统核心确定，应用进程无法影响线程的切换

##### b) 纯用户空间多线程(协程)
![20220225142709.jpg](https://pic.imgdb.cn/item/621878342ab3f51d915f313e.jpg)

优点
* 切换速度快，调度算法可专用(用户态去写，去调用)
* 可运行在任何操作系统上

缺点
* 阻塞问题，如果某个用户线程被阻塞，导致进程同样被阻塞

##### b) 混合版本(go中的协程)

![20220225143923.jpg](https://pic.imgdb.cn/item/621879a72ab3f51d9162e356.jpg)

* c/c++本身没有多线程机制，需要利用操作系统API实现多线程pthread库：pthread_create,pthread_mutex_init,...

* java中本身支持多线程：synchronized,Thread/Runnable,Java Concurrent Util库。

### 5、线程任务调度
大部分操作系统的任务调度是采用**时间片轮转的抢占式调度方式**。

**在一个进程中，当一个线程任务执行几毫秒后，会由操作系统的内核进行调度，通过硬件的计数器中断处理器，让该线程强制暂停并将该线程的寄存器放入内存中，通过查看线程列表决定接下来执行哪一个线程，并从内存中恢复该线程的寄存器，最后恢复该线程的执行，从而去执行下一个任务。**

上述过程中，**任务执行的那一小段时间叫做时间片，任务正在执行时的状态叫运行状态，被暂停的线程任务状态叫做就绪状态，意为等待下一个属于它的时间片的到来。**

这种方式保证了每个线程轮流执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发(并发的实现很复杂，但它的概念很简单，就是一句话：多个任务同时执行)。多任务运行过程的示意图如下：

![188299514_3_20200417020555666.jpeg](https://pic.imgdb.cn/item/62174ce32ab3f51d912e48df.jpg)

![90384A12-1510-40F9-BB6B-78A61F5271CC.png](https://pic.imgdb.cn/item/62184cfc2ab3f51d91037b0f.png)

### 6、为什么要多开线程
是因为服务器的程序往往都是IO密集型的应用。多线程可以让CPU跑满。

优点：
* **提高CPU的利用率**：通俗点讲，就是不能让CPU闲着。当一个线程发送IO时，会把该线程从CPU上调度下来，并把其他的线程调度上去，继续计算。

* **提高IO吞吐**：典型的应用场景是应用程序连接的redis和mysql，他们提供的都是同步接口，一次只能处理一个请求。想要并发，办法是通过连接池和多线程，实现每个线程都用一个连接。好比在客户端和服务端之间开了多条通道，并行传输数据。

说明:
* 单核也要用多线程，因为假如某个线程阻塞了，则系统可以暂停执行该线程，去执行其他线程。

### 7、线程撕裂者

超线程：比如4核8线程 

 ![ABE5581E-B66D-4E30-8911-D7AADC7AF144.png](https://pic.imgdb.cn/item/621853652ab3f51d910fd970.png)

CPU的主要组成：
* 指令计数器PC：
作用：保存下一跳指令的地址，CPU在运行的时候会根据指令寄存器中保存的地址从内存中获取数据，获取完后回保存到CPU的寄存器中。
* 寄存器 Registers：
作用：用来保存从内存中读取过来的数据
* 运算单元ALU：
作用：根据根据寄存器中保存的数据做运算，算完后再写入到内存中
* 高速缓存 Cache：
作用：即1/2/3级缓存，用来缓存内存中的数据，避免直接从内存中获取，提升CPU的运算周期效率。

为了提升ALU的计算周期利用率，一个ALU 可以对应 两组 寄存器+指令计数器，这样一个核就可以装两个线程，ALU切换计算两组寄存器+指令计数器中的指令，这样即提升了计算周期，也可以很大程度省区切换线程恢复数据的周期。

### 8、线程的生命周期
当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。

进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。
* 创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；
* 就绪：时间片已用完，此线程被强制暂停，等待下一个属于它的时间片到来；
* 运行：此线程正在执行，正在占用时间片；
* 阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；
* 退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。

![188299514_15_20200417020557260.jpeg](https://pic.imgdb.cn/item/62179c832ab3f51d91034347.jpg)

### 9、多线程与多核
很多操作系统的书都说“同一时间点只有一个任务在执行”。这句话是不准确的，至少它是不全面的。

多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。

**内核线程（Kernel Thread，KLT）**就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般**一个处理核心对应一个内核线程**，比如双核处理器对应两个内核线程。

现在的电脑一般是双核四线程、四核八线程，是采用**超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程**，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍。

超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。

程序一般不会直接去使用内核线程，而是去使用**内核线程的一种高级接口——轻量级进程（Lightweight Process，LWP）**，轻量级进程就是我们通常意义上所讲的线程，也被叫做用户线程。由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型，在这以4个内核线程、3个用户线程为例对三种模型进行说明。

##### a) 一对一模型

一个用户线程唯一地对应一个内核线程。如果CPU没有采用超线程技术，一个用户线程就唯一地映射到一个物理CPU的内核线程，线程之间的并发是真正的并发。

![188299514_9_2020041702055658.jpeg](https://pic.imgdb.cn/item/62176c9b2ab3f51d91781a00.jpg)

一对一模型使用户线程具有与内核线程一样的优点:
* 一个线程因某种原因阻塞时其他线程的执行不受影响。
* 一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。

但也有缺点：
* 许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；
* 许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。

##### b) 多对一模型
将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，系统内核感受不到线程的实现方式。用户线程的建立、同步、销毁等都在用户态中完成，不需要内核的介入。

![188299514_10_20200417020556682.jpeg](https://pic.imgdb.cn/item/62176d662ab3f51d917a3f17.jpg)

因此相对一对一模型，优点为：
* 多对一模型的线程上下文切换速度要快许多；
* 多对一模型对用户线程的数量几乎无限制。

但也有缺点：
* 如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；
* 在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。

##### c) 多对多模型
多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。由线程库负责在可用的可调度实体上调度用户线程，这使得线程的上下文切换非常快，因为它避免了系统调用。但是增加了复杂性和优先级倒置的可能性，以及在用户态调度程序和内核调度程序之间没有广泛（且高昂）协调的次优调度。

在现在流行的操作系统中，大都采用多对多的模型。

![188299514_11_20200417020556791.jpeg](https://pic.imgdb.cn/item/62176df42ab3f51d917bc17e.jpg)

多对多模型的优点有：
* 一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；
* 多对多模型对用户线程的数量没有限制；
* 在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。

## 三、协程(coroutine)

协程，**另外一种支持并发的方式**，适合IO频繁的场景。

协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做**用户空间线程**，具有对内核来说不可见的特性。

自主调用来支持多并发，**所有切换都交给用户层的协程调度器来完成**。

因为是自主开辟的异步任务，所以很多人也更喜欢叫它们纤程（Fiber，windows中叫法），或者绿色线程（GreenThread）。正如一个进程可以拥有多个线程一样，**一个线程也可以拥有多个协程**。

![20220225103251.jpg](https://pic.imgdb.cn/item/62183fdc2ab3f51d91e89237.jpg)

### 1、协程的目的
在传统的J2EE系统中都是基于每个请求占用一个线程去完成完整的业务逻辑（包括事务）。所以系统的吞吐能力取决于每个线程的操作耗时。如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。

最常见的例子就是JDBC（它是同步阻塞的），这也是为什么很多人都说数据库是瓶颈的原因。这里的耗时其实是让CPU一直在等待I/O返回，说白了线程根本没有利用CPU去做运算，而是处于空转状态。而另外过多的线程，也会带来更多的ContextSwitch开销。

对于上述问题，现阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。

而协程的目的就是当出现长时间的I/O操作时，通过让出目前的协程调度，执行下一个任务的方式，来消除ContextSwitch上的开销。

### 2、协程的特点
* 线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。
* 适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好是用线程去解决。

### 3、协程的原理
当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别，这整个流程可以称为coroutine，而跑在由coroutine负责调度的线程称为Fiber。比如Golang里的 go关键字其实就是负责开启一个Fiber，让func逻辑跑在上面。

由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。因此，协程的开销远远小于线程的开销，也就没有了ContextSwitch上的开销。

### 4、优点
* **协程的切换由用户自己进行调度，因此减少了上下文切换，提高了效率**。

* **线程申请内存，需要走内核，而协程申请内存，不需要走内核**。

* 由于在同一个线程上，也不存在同时写变量冲突，因此可以避免竞争关系而使用锁。只需要判断状态就好了，所以执行效率比多线程高很多。

* 并发度更高
    协程资源占用小，不会带来严重的性能问题。一台机器，多线程通常开几百个，而如果用协程，能开几千/几万个。

* 代码可读性强-用同步代码写出异步程序
    用多线程就涉及到异步程序，异步程序的典型模式callback很容易产生callback hell(回调地狱)，回调里面嵌套回调，代码可读性、程序调试都很麻烦。

    为了让异步编程更简便，java里面有了Future,但还是不够直观。

### 5、缺点
* 如果某个用户线程被阻塞，导致进程同样被阻塞。

### 6、协程区别线程/进程的核心特征
##### a）线程/进程的调度都是由操作系统决定的，应用程序干预不了
操作系统决定：某个进程/线程**调入**某个cpu执行，某个进程/线程从某个cpu**调出**。
调出的时间点：**时间片用完，IO等待，线程锁，sleep函数**。。。

协程的调度由应用程序自己控制，应用程序决定某个协程放弃cpu，某个协程占用cpu。

##### b) 协程因为是应用程序层面的概念，操作系统并不感知。
所以协程的底层，还是依赖多个线程来执行。
M:N模型：M个协程，跑在N个固定的线程上面。

##### c) **线程是抢占式的，协程是协作式的**

### 7、多协程的使用场景

- 运算量比较多
- 协程间依赖性比较弱

### 8、多协程的局限性

如果分配工作耗时为T1,并发运算时的耗时为T2，合并结果的耗时为T3.

如果T1>T2 或 T3>T2  或 T1+T3>T2，则不建议用多协程。因为可能会带来额外的耗时，额外的内存消耗。

### 9、实际应用

##### a) c/c++
原生没有协程支持，需要上层应用自己实现
以前用协程非常少，现在逐渐增多。

* 微信开源的协程库libco（需要用到汇编语言） 
* 百度开源的brpc里面的bthread
* boots::fiber

##### b）java
以前原生的jdk不支持，目前在逐步支持，但不成熟。
* Quasar
* Loom

备注：java里面已经有一套非常早，完善的多线程库juc，用协程动力不足。

##### c） go
原生支持多协程，很容易写出高并发的服务器程序。

## 四、用户态和内核态

### 1、先说下用户空间和内核空间

虚拟内存被操作系统划分成两块：内核空间和用户空间。为了安全，它们是隔离的，即使用户的程序崩溃了，内核也不受影响。

- **内核空间是内核代码运行的地方，是受保护的内存空间。**
- **用户空间是用户应用程序运行访问的内存区域。**

### 2、用户态和内核态

* 用户态：cpu执行用户程序自己的代码，即当进程运行在用户空间时。
* 内核态：cpu执行操作系统内核代码，即进程运行在内核空间时。

java 的jvm中用户态线程和内核态线程是1:1关系，即一个用户态线程绑定一个内核态线程。

系统调用是一个进程从用户态进入内核态的切换点。

## 五、总结

### 1、现状
当前：**最成熟、完善的是多线程程序。**
未来：多协程，GO原生支持，C++/JDK对协程的支持也越来越完善。

### 2、异步IO+单线程：

有了异步IO，cpu没有IO等待，cpu不空闲，能充分利用，就可能用单线程解决问题，比如Redis。

## 六、其他

* io的读写不需要cpu参与
* 一台服务器，线程模型，最多10w的并发连接，如果协程模型，可以支持百万并发连接。

### 1、并发和并行区别

* 并发：并发的关键是你有处理多个任务的能力，不一定要同时。比如多线程程序在一个核的cpu上运行，就是并发。

* 并行：并行的关键是你有同时处理多个任务的能力。比如多线程程序在多个核的cpu上运行，就是并行。 

### 2、内存消耗

- 一个线程大约8M内存大小
- 一个协程大约2KB内存大小

  