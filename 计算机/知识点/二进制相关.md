## 二进制相关

## 一、十进制与二进制的相互转换

### 1、整数部分采用除2倒取余法

具体做法：用2去除十进制整数，可以得到一个商和余数；在用2去除商，又会得到一个商和余数，如此进行，直到商为0时为止，**然后把先的到的余数作为二进制的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。**

比如4 = 100

### 2、小数部分采用乘2取整法

具体做法：用2乘十进制小数，可以得到积，将积中的整数部分取出，在用**2乘余下的小数部分**，又得到一个积，在将积中的整数部分取出，如此进行，直到积中的小数部分为0，此时0或1为二进制的最后一位，**或者达到所要求的精度为止**，然后把取出的整数部分按顺序排列起来，**先取得整数作为二进制小数的最高位有效位，后取的整数作为低位有效位。**

比如0.125 = 0.001

![](https://pic.imgdb.cn/item/631c6fa816f2c2beb109cb9f.png)

## 二、二进制转换为十进制

### 1、整数部分按照**按权相加法**

即将二进制每位上的数乘以权，然后相加之和即是十进制数。

比如：100 = 1\*2的2次方+ 0\*2的1次方+0\*2的0次方 = 4

### 2、小数部分采用除2法

比如0.001 = 0/2 + 0/4 + 1/ 8 = 0.125

## 三、真值

真值是用二进制数直接表示这个数（无符号位）。

如： 十进制中4的真值==0100（二进制） 十进制中-5的真值==-0101  	//符号+数值的绝对值

## 四、原码

**原码是真值加上符号位，是计算机中数据存放的形态，是最简单的机器数表示法，用最高位表示符号位，其他位存放该数的二进制的绝对值**。

最高位1表示这是负数，0表示正数。

以带符号位的四位二进制数为例：1010表示十进制数-2。0000表示0，1000表示-0。

### 1、原码计算

> 0001+0010=0011，1+2=3；
> 0000+1000=1000，+0+(-0)=-0；
> 0001+1001=1010，1+(-1)=-2。 // 出错

于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。

### 2、原码的特点

1. 原码表示直观、易懂，与真值转换容易。

2. 原码中0有两种不同的表示形式，给使用带来了不便。

   通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。

3. 原码表示加减运算复杂。

   利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。

原码最大的问题就在于一个数加上它的相反数不等于0，于是反码的设计思想就是冲着解决这一点，既然一个负数是一个正数的相反数，那干脆用一个正数按位取反来表示负数。

## 五、反码

**正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反**。

**反码表示在计算机中往往作为数码变换的中间环节。**

比如：-3的原码是1011，符号位保持不变，低三位按位取反，所以-3的反码为1100。

### 1、反码的计算

> 0001+1110=1111，1+(-1)=-0；
> 1110+1100=1010，(-1)+(-3)=-5。// 出错了，因为进位了，但是最高位被舍弃了

互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加的出错了。

### 2、反码的特点

1. 在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即0为正；1为负。
2. 在反码表示中，数值0有两种表示方法。
3. 反码的表示范围与原码的表示范围相同。

反码的问题是当出现溢出时，高位被舍弃，导致出现问题。于是就出现了补码。

## 六、补码

**正数的补码等于它的原码；负数的补码等于反码+1(即2的负n，n为小数的个数)**（这只是一种算补码的方式，不是定义）。

**或者说补码=模+负数=模-|负数|。（模=负数2的n方(n为寄存器位数)）**

补码的思想其实就是来自于生活，思想其实就类似于生活中的时钟**。

> 简单，过去隔两个小时的时候是八点钟，未来过十个小时的时候也是八点钟。
> 也就是说时间倒拨2小时，或正拨10小时都是八点钟。
> 也就是10-2=8，而且10+10=8。
> 这个时候满12，说明时针在走第二圈，又走了8小时，所以时针正好又停在八点钟。

所以12在时钟运算中，称之为模，超过了12就会重新从1开始算了。也就是说，10-2和10+10从另一个角度来看是等效的，它都使时针指向了八点钟。

既然是等效的，那么在时钟运算中，减去一个数，其实就相当于加上另外一个数（**这个数与减数相加正好等于12，也称为同余数**），这就是补码所谓运算思想的生活例子。

那么为什么负数补码是反码+1呢？

### 1、为什么需要补码

因为 “0” 这个特殊数字的存在。

将减法运算按加法运算处理，负数需要用反码表示，那么用 **8 位二进制反码表示的正数范围：+0 —— +127；负数范围：-127 —— -0**。但是，其中有两个特殊的编码会出现：

正0 [0_0000000]=+0 （反码）

负0 [1_1111111]=-0 （反码）

+0 和 -0 代表的都是 0。这样一来，“0” 这个数字在计算机中的编码就不是唯一的了。对于计算机来说，这是绝对不行的，因为任何数字都只能有 1 个编码。

我们知道 0 既不是正数也不是负数，为了解决这个编码不唯一的问题，把 0 当成正数，也即 +0，这样 0 的编码就变成：0_0000000。那 8 位二进制表示的正数范围仍然是：+0 —— +127。**负数整体向后“挪动1位”，反码 +1**，{1_1111111}编码就不再表示 -0，而变成了 -1。顺着推，最小的编码{1_0000000}就是 -128，8 位二进制表示的负数范围从：-127 —— -0 变成：-128 —— -1，就能成功解决问题。

### 2、补码的特点

1. 在补码表示中，用符号位表示数值的正负，形式与原码的表示相同，即0为正，1为负。但补码的符号可以看做是数值的一部分参加运算。

> 正数的补码表示就是其本身，负数的补码表示的实质是把负数映像到正值区域，因此加上一个负数或减去一个正数可以用加上另一个数（负数或减数对应的补码）来代替。
> 从补码表示的符号看，补码中符号位的值代表了数的正确符号，0表示正数，1表示负数；而从映像值来看，符号位的值是映像值的一个数位，因此在补码运算中，符号位可以与数值位一起参加运算。

2. 在补码表示中，数值0只有一种表示方法。

3. 负数补码的表示范围比负数原码的表示范围略宽。纯小数的补码可以表示到-1，纯整数的补码可以表示到-2^n。

由于补码表示中的符号位可以与数值位一起参加运算，并且可以将减法转换为加法进行运算，简化了运算过程，因此**计算机中均采用补码进行加减运算**。 

## 七、移码

原码加模后的值，就是在真值x上加上一个常数（偏置值，即模），通常这个数取2的n方(n为寄存器位数)，相当于x在数轴上向正方向偏移了若干单位。

比如四位的二进制，偏移量就是2的4次方=16.

移码用于比较大小。因为补码表示很难直接判断其真值大小(有时还会出错)。

## 八、乘法怎么算

对于计算机而言，左移一位代表乘以2，右移一位代表除以2。那么规则就是，按照被乘数的低位到高位依次计算，如果第n位不为0，那么乘数就左移n位，如果第n为为0 ，那么这步运算结果记为0，最后将每一步的结果相加就是最终的计算结果。

比如3*5, 3为乘数，2为被乘数。

1. 3=0011,2=0101
2. 5的第0位为1, 运算结果为3的二进制左移0位=3；
3. 5的第1位为0， 运算结果为0。
4. 5的第1位为1， 运算结果为3的二进制左移2位=12；
5. 然后将其累加，得到最后结果15。

## 九、除法怎么算

todo

https://www.cnblogs.com/stigerzergold/p/10328472.html

## 十、计算机和二进制

计算机都是是以源码存储，只是在计算时候用补码计算。

### 1、计算机是怎么识别高位的符号位的

其实这里说的笼统的“计算机”，包含两部分：CPU、程序

从CPU角度，永远没有符号位，一切数据按补码格式处理

从程序角度，又有两种情况：

- 一是已经被编译为机器指令，等待CPU处理的流，这里的数据也完全是补码形式
- 二是面向开发者、编辑器的程序，这就根据不同的程序设计语言来看数据是否是有符号位的数

所以在编程时定义了数据类型（是否有符号）,编译器便会自动判别、处理，转换为补码形式交给cpu处理。

## 十、总结

- 计算机没有减法器，做不了减法。
- 原码、反码、补码的产生过程就是为了解决计算机做减法和引入符号位的问题。
- 正数：原码=反码=补码，因为正数不涉及减法运算。
- 补码非常适合非门电路，即补码是给计算器用的。
- 模=2的n方(n为寄存器位数)
- **采用补码可以简化计算机硬件电路设计的复杂度。**
- 乘法除法最终也是转换为加法去处理。