## 内存

## 一、基础知识

* 内存中数据有读、写、执行等权限，是为了保护程序正常运行。

### 1、内存管理

内存管理主要包括两个动作：分配与释放。逃逸分析就是服务于内存分配。

### 2、内测泄露和内存溢出

- 内存泄漏memory leak :是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。
- 内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，比如说给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。
- 二者的关系：内存泄漏的堆积最终会导致内存溢出

### 3、数据类型本质：

 固定内存大小的别名

### 4、数据类型的作用：

 编译器预算对象(变量)分配的内存空间大小。

## 二、内存四区

### 1、栈区(Stack)：

空间较小，要求数据读写性能高，数据存放时间较短暂。由**编译器自动分配和释放**，一般存放函数的参数值、函数的调用流程方法地址、局部变量等(局部变量如果产生逃逸现象，可能会挂在在堆区)

栈使用的是一级缓存，他们通常都是被调用时处于存储空间中，调用完毕立即释放。

栈（Stack）是一种线性结构，它的内存空间是连续的，类似于一堆盘子叠在一起，后进先出。每个线程都会有自己的栈，用来存储函数调用时的临时数据，如局部**变量、参数、返回值**等。因为栈的内存空间是连续的，所以访问速度非常快，同时由于系统自动管理，所以也不**容易出现内存泄漏和悬垂指针**等问题。

### 2、堆区(heap):

空间充裕，数据存放时间较久。**一般由开发者分配及释放**(但是Golang中会根据变量的逃逸现象来选择是否分配到栈上或堆上，启动Golang的GC由GC清除机制自动回收，不需要开发者手动介入)。

堆则是存放在二级缓存中，生命周期由机器的垃圾回收算法来决定(并不是一旦成为孤儿对象就能被
回收)。所以调用这些对象的速度要相对来得低一些。

堆（Heap）是一种**动态分配内存的机制**，它的内存空间是不连续的，类似于一大堆散装货物。在堆中分配的内存需要手动申请和释放，因此**需要开发者自己管理**。堆的内存空间通常用于存储比较大的数据结构，如动态数组、哈希表、二叉树等。堆的内存空间是不连续的，因此访问**速度相对较慢**，同时由于需要手动管理，**容易出现内存泄漏和悬垂指针**等问题。

堆在内存分配中类似于往一个房间里摆放各种家具，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，即碎片整理。

### 3、全局区:

##### a) 静态全局变量区

全局变量的开辟是在程序在main之前就已经放在内存中。而且对外完全可见。即作用域在全部代码中，任何同包代码均可随时使用，在变量会搞混淆，而且在局部函数中如果同名称变量使用:=赋值会出现编译错误。

全局变量最终在进程退出时，由操作系统回收。

> 我么在开发的时候，尽量减少使用全局变量的设计

##### b) 常量区：

常量区也归属于全局区，常量为存放数值字面值单位，即不可修改。或者说的有的常量是直接挂钩字面值的。

比如:
const cl = 10
cl是字面量10的对等符号。

所以在golang中，常量是无法取出地址的，因为字面量符号并没有地址而言。

### 4、代码区
