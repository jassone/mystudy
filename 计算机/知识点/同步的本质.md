## 同步的本质
**就是实现临界区的互斥性。**

## 一、相关概念
### 1、临界区
* ​用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但每一次只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源就必须等待。

* 在并行程序中，临界区资源是保护的对象。

所以程序要做到对于临界区操作的互斥性。

### 2、硬件指令
软件层面不能保证原子操作，只能依靠硬件的支持。因为任何软件层面的指令序列，都可能因硬件中断而打断，只有在硬件层面的原子性指令，才能保证在其执行期间不会插入其他指令。

这里有三个硬件指令(硬件原语)
* Compare And Swap (CAS)
* Fetch And Add
* Test And Set

硬件层面不可能对所有临界区的任务都提供相应的原子指令。但是可以在上面三个硬件指令的基础上，实现一个原子锁。

锁，本质上就是一个变量，硬件提供的原子指令，让线程可以原子性的改变这个变量到某个状态，这样就算获得锁。相应的，释放锁，就是原子性的将该变量恢复到某个状态。

##### a)单核情况
如果线程只有在获得锁之后，才可以进入临界区执行，即使因为硬件中断等原因导致持有锁的线程中断执行，其他线程也会因为无法获得锁而不能进入临界区。持有锁的线程只有在完成临界区的操作后才会释放锁。那么同一时刻只有一个线程能够进入临界区。只要保障临界区操作的互斥性，就能实现同步。

##### b)多核情况
多核情况下，仅仅依靠CAS这一类硬件原语，并不能实现原子同步，要知道即使是原子指令，底层实现也可能包含多条微指令，而原子指令的原子性是相对于一个CPU核而言的。也就是说，硬件可以保障在一个CPU核上原子指令执行期间，中间不会插入其他指令。

但是若并行在两个核上的线程a和线程b，同时尝试获得锁，都要执行原子指令，总线接收到的原子指令可能是：a读，b读，a写，b写。结果可能是两个线程都获得了锁，都进去了临界区(但a和b的内部都是各个原子性的)。

要解决这个问题，就得把总线锁住，这样只有一个执行体能获得锁了。比如go中Mutex的实现，提前lock总线，由并行转为串行，必然会影响性能。

但是现在CPU都拥有高速缓存，不再通过锁总线的方式来实现多核间同步，为了保证多核间高速缓存的一致性，引入了**d协议(高速缓存一致性协议)**。

### 3、硬件原语
todo

