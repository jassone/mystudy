## 概述
Apache 2.X  支持插入式并行处理模块，称为多进程处理模块（MPM）。在编译apache时必须选择也只能选择一个MPM，对类UNIX系统，有几个不同的MPM可供选择，它们会影响到apache的速度和可伸缩性。

Apache目前一共有三种稳定的**MPM**（Multi-Processing Module，多进程处理模块）模式。它们分别是prefork，worker和event，它们同时也代表这Apache的演变和发展。

Apache在configure配置编译参数的时候，可以使用 --with-mpm=prefork|worker|event 来指定编译为那一种MPM，当然也可以用编译为三种都支持：--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM。

## 查看工作模式
* 查看Apache工作模式(yum安装的)
    apachectl -l
* 查看Apache版本信息及工作模式
    apachectl -V
* 查看Apache编译安装的参数
    cat  /usr/local/apache2/build/config.nice
    "--with-mpm=worker" \

## prefork模式-多进程工作模式
### 工作原理
prefork模式（默认模式）是很古老但是非常稳定的模式。使用的是多个子进程，先生成主进程，完成基础的初始化工作，然后，通过fork预先产生一批的子进程（子进程会复制父进程的内存空间，不需要再做基础的初始化工作），然后等待服务，并且总是视图保持一些备用的子进程。为了不在请求到来时再生成子进程，所以要根据需求不断的创建新的子进程，最大可以达到每秒32个直到满足需求为止。之所以这样做，是为了减少频繁创建和销毁进程的开销。每个子进程中只有一个线程，在一个时间点内，只能处理一个请求。

在Unix系统中，父进程通常以root身份运行以便邦定80端口，而 Apache产生的子进程通常以一个低特权的用户运行。User和Group指令用于配置子进程的低特权用户。运行子进程的用户必须要对他所服务的内容有读取的权限，但是对服务内容之外的其他资源必须拥有尽可能少的权限。

![1046690-20170516152749103-350568827.gif](https://pic.imgdb.cn/item/611ef73e4907e2d39c779098.gif)

### 安装方法
在编译安装Apache的过程中，加入参数--with-mpm=prefork即可，如果不加也可以，因为Apache默认会采用prefork模式进行编译安装。也可以使用--enable-mpms-shared=all，这样在编译的时候会在modules目录下自动编译出三个MPM文件的so，然后通过修改httpd.conf配置文件更改MPM即可。

### 优缺点
优点：成熟，兼容所有新老模块。多进程的好处，是进程之间的内存数据不会相互干扰，同时，某个进程异常终止也不会影响其他进程。不需要担心线程安全的问题。（我们常用的mod_php，PHP的拓展不需要支持线程安全）

缺点：适合于没有线程安全库，需要避免线程兼容性问题的系统。
每个子进程占用了很多的内存，因为子进程的内存数据是复制父进程的。存在大量的“重复数据”被放在内存中。最终，导致我们能够生成的子进程最大数量是很有限。
在面对高并发时，因为有不少Keep-alive的长连接，将这些子进程“霸占”住，很可能导致可用子进程耗尽。因此，prefork并不太适合高并发场景(在这种场景下，它会将请求放进队列中，一直等到有可用进程，请求才会被处理。).

### 配置参数说明

```
[root@localhost ~]# vim /usr/local/apache2/conf/extra/ httpd-mpm.conf

<IfModule mpm_prefork_module>
    StartServers             5       服务启动时初始的进程数，默认5

    MinSpareServers          5      最小的空闲子进程数，默认5

    MaxSpareServers         10      最大的空闲子进程数，默认10

    MaxRequestWorkers      250    限定同一时间内客户端最大接入的请求数量，默认是250  

    MaxConnectionsPerChild   0      每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。
    建议设置为非零，原因：
    （1）.能够防止(偶然的)内存泄漏无限进行，从而耗尽内存。 
    （2）.给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量(重生的机会)。
</IfModule>
```

## worker模式-多进程和多线程的混合模式
worker模式和prefork模式相比，worker模式使用了多进程和多线程的混合模式，worker模式也同样会先预派生一些子进程，<font color="red">然后每个子进程创建一些线程，同时包括一个监听线程，每个请求过来会被分配到一个线程来服务。</font>线程比起进程会更轻量，因为线程是通过共享父进程的内存空间，因此，内存的占用会减少一些，在高并发的场景下会比prefork有更多可用的线程，表现会更优秀一些。

另外，如果一个线程出现了问题也会导致同一进程下的线程出现问题，如果是多个线程出现问题，也只是影响Apache的一部分，而不是全部。由于用到多进程多线程，需要考虑到线程的安全了（多个线程修改共享资源导致的“竞争行为”，因此，一定程度上增加Web服务的不稳定性）。在使用keep-alive长连接的时候，某个线程会一直被占用，即使中间没有请求，需要等待到超时才会被释放（该问题在prefork模式下也存在）。

Apache总是试图维持一个备用(spare)或是空闲的服务线程池。这样，客户端无须等待新线程或新进程的建立即可得到处理。在Unix中，为了能够绑定80端口，父进程一般都是以root身份启动，随后，Apache以较低权限的用户建立子进程和线程。User和Group指令用于配置Apache子进程的权限。虽然子进程必须对其提供的内容拥有读权限，但应该尽可能给予他较少的特权。另外，除非使用了suexec ，否则，这些指令配置的权限将被CGI脚本所继承。

![1046690-20170516153604838-1107105185.gif](https://pic.imgdb.cn/item/611ef78c4907e2d39c780fe6.gif)

### 安装方法

在编译安装Apache的过程中，加入参数--with-mpm=worker即可进行编译安装。其他同上

### 优缺点
优点：占据更少的内存，高并发下表现更优秀。

缺点：必须考虑线程安全的问题，如果过多的线程，被keep-alive的长连接方式占据，也会导致在高并发场景下的无服务线程可用。（该问题在prefork模式下，同样会发生）。

说明：http1.1的keep-alive的长连接方式，是为了让下一次的socket通信复用之前创建的连接，从而，减少连接的创建和销毁的系统开销。保持连接，会让某个进程或者线程一直处于等待状态，即使没有数据过来。

### 配置参数说明

```
<IfModule mpm_worker_module>
    StartServers             3       服务启动时初始的进程数，默认3

    MinSpareThreads         75     最小的空闲子进程数，默认75

    MaxSpareThreads        250      最大的空闲子进程数，默认250

    ThreadsPerChild         25      每个子进程产生的线程数量，默认是25

    MaxRequestWorkers      400   限定同一时间内客户端最大接入的请求数量，默认是400

    MaxConnectionsPerChild   0 每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。
    建议设置为非零，原因：
    （1）.能够防止(偶然的)内存泄漏无限进行，从而耗尽内存。 
    （2）.给进程一个有限寿命，从而有助于当服务器负载减轻的时候减少活动进程的数量(重生的机会)。
</IfModule>
```

## event模式-多进程和多线程的混合模式，引入Epoll
### 工作原理
event是Apache最新的工作模式，它和worker模式很像，不同的是在于它解决了keep-alive长连接的时候占用线程资源被浪费的问题。

在event工作模式中，会有一些专门的线程用来管理这些keep-alive类型的线程，当有真实请求过来的时候，将请求传递给服务器的线程，执行完毕后，又允许它释放。这样，一个线程就能处理几个请求了，实现了异步非阻塞。这增强了在高并发场景下的请求处理。

event工作模式在遇到某些不兼容的模块时，会失效，将会回退到worker模式，一个工作线程处理一个请求。官方自带的模块，全部是支持event工作模式的。

event工作模式需要Linux系统（Linux 2.6+）对epoll的支持，才能启用。需要补充的是HTTPS的连接（SSL），它的运行模式仍然是类似worker的方式，线程会被一直占用，直到连接关闭。部分比较老的资料里，说event MPM不支持SSL，那个说法是几年前的说法，现在已经支持了。

![1046690-20170516154557885-1642813970.gif](https://pic.imgdb.cn/item/611ef82a4907e2d39c7903ab.gif)

### 安装方法
在编译安装Apache的过程中，加入参数--with-mpm=event即可进行编译安装。其他同上

### 优缺点
优点：event模式是最节约内存的

### 配置参数说明
```
<IfModule mpm_event_module>
    StartServers             3    服务启动时初始的进程数，默认3

    MinSpareThreads         75  最小的空闲子进程数，默认75

    MaxSpareThreads        250  最大的空闲子进程数，默认250

    ThreadsPerChild         25   每个子进程产生的线程数量，默认是25

    MaxRequestWorkers      400  限定同一时间内客户端最大接入的请求数量，默认是400

MaxConnectionsPerChild   0 每个子进程在其生命周期内允许最大的请求数量，如果请求总数已经达到这个数值，子进程将会结束，如果设置为0，子进程将永远不会结束。将该值设置为非0值，可以防止运行PHP导致的内存泄露。
</IfModule>
```

## 工作模式与web应用的选择
Apache能更好的为有特殊要求的站点定制。例如，要求 更高伸缩性的站点可以选择使用线程的 MPM，即 worker 或 event； 需要可靠性或者与旧软件兼容的站点可以使用 prefork。就使用PHP而言，fastCGI和php-fpm是更推荐的使用模式。

现在的最新浏览器，在单个域名下的连接数变得越来越多（通常都是使用keep-alive），主流浏览器是2-6个（还有继续增长趋势，为了加快页面的并发下载速度）。高并发场景，会越来越成为Web系统的一种常态。Apache很成熟，同时也背负了比较重的历史代码和模块，因此，在Web系统比较方面，Nginx在不少场景下，表现比起Apache更为出色。