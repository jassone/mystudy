## main

### 1、如何在容器内访问宿主机服务

- 使用宿主机和端口的方式

- 利用主机名访问:

​	在 Docker 容器内,可以通过 `host.docker.internal` 来访问宿主机上的服务。这个域名会自动解析到宿主机的 IP 地址,不受 IP 变化的影响。

​       比如 http://host.docker.internal:8000

       ```
       同时需要启动服务时候  docker run --add-host=host.docker.internal:host-gateway <image>
       在容器内ping host.docker.internal  为 172.17.0.1 ，因为这个是docker起的一个虚拟网卡地址
       
       ifconfig
       docker0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
               inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
               inet6 fe80::42:fcff:fee8:d64e  prefixlen 64  scopeid 0x20<link>
               ether 02:42:fc:e8:d6:4e  txqueuelen 0  (Ethernet)
               RX packets 2531376  bytes 2572058100 (2.5 GB)
               RX errors 0  dropped 0  overruns 0  frame 0
               TX packets 3296945  bytes 4967384414 (4.9 GB)
               TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
       ```

​       

- 使用环境变量:

​	在启动容器时,可以通过 `-e` 参数传递宿主机的 IP 地址作为环境变量。然后在容器内部使用这个环境变量来访问宿主机的服务。

​	例如: `docker run -e HOST_IP=192.168.1.100 my-container`

- 利用 DNS 服务:

​	可以在容器启动时设置 DNS 服务器,指向一个能够解析主机名的 DNS 服务器。这样就可以使用主机名而不受 IP 变化的影响。

​	例如: `docker run --dns 8.8.8.8 my-container`

- 使用服务发现机制:

​	可以引入一个服务发现组件,如 Consul 或 Zookeeper,让容器和主机互相注册服务。这样就可以通过服务名称来访问,而不需要关心具体的 IP 地址。

### 2、时区问题

```
这种方法会设置容器内部的时区，但并不会改变宿主机的时区。  好像不太好使
docker run -e TZ="Asia/Shanghai" <image-name>


容器会使用宿主机的时区设置。
docker run -v /etc/timezone:/etc/timezone -v /etc/localtime:/etc/localtime:ro <image-name>


与 -e 类似，--env 也可以设置时区。  没试过
docker run --env TZ=Asia/Shanghai <image-name>

```

