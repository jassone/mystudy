## fork
## 一、示例
```php
$pid = pcntl_fork();
if ($pid == -1)
{
    die("could not fork");
}
elseif($pid == 0)
{
    echo "I'm the child  process \n";
}
else
{
    echo "I'm the parent process \n";
    exit;
}
```
输出：
I'm the parent process 
I'm the child  process 

## 二、流程梳理

### 1、进程是什么
一个进程，主要包含三个元素：
 
1. 一个可以执行的程序；
2. 和该进程相关联的全部数据（包括变量，内存空间，缓冲区等等）；
3. 程序的执行上下文（execution context）；
 
不妨简单理解为，一个进程表示的就是一个可执行程序的一次执行过程中的一个状态。操作系统对进程的管理，典型的情况，是通过进程表完成的。进程表中的每一个表项，记录的是当前操作系统中一个进程的情况。对于单 CPU的情况而言，每一特定时刻只有一个进程占用 CPU，但是系统中可能同时存在多个活动的（等待执行或继续执行的）进程。
 
一个称为”程序计数器（program counter, pc）”的寄存器，指出当前占用 CPU的进程要执行的下一条指令的位置。
 
当分给某个进程的 CPU时间已经用完，操作系统将该进程相关的寄存器的值，保存到该进程在进程表中对应的表项里面；把将要接替这个进程占用 CPU的那个进程的上下文，从进程表中读出，并更新相应的寄存器（这个过程称为”上下文交换(process context switch)”，实际的上下文交换需要涉及到更多的数据那。

主要要记住程序寄存器pc指出程序当前已经执行到哪里，是进程上 下文的重要内容，换出 CPU的进程要保存这个寄存器的值，换入CPU的进程，也要根据进程表中保存的本进程执行上下文信息，更新这个寄存器）。
 
### 2、pcntl_fork说明
```php
pid = pcntl_fork();
```
操作系统创建一个新的进程（子进程），并且在进程表中相应为它建立一个新的表项。新进程和原有进程的可执行程序是同一个程序；上下文和数据，绝大部分就是原进程（父进程）的拷贝，但它们是两个相互独立的进程！此时程序寄存器pc在父、子进程的上下文中都声称，这个进程目前执行到fork调用即将返回（此时子进程不占有CPU，子进程的pc不是真正保存在寄存器中，而是作为进程上下文保存在进程表中的对应表项内）。问题是怎么返回，在父子进程中就分道扬镳。
 
父进程继续执行操作系统对fork的实现，使这个调用在父进程中返回刚刚创建的子进程的pid（一个正整数），所以后面的if语句中pid<0, pid==0的两个分支都不会执行。所以输出：i am the parent process…
 
接着子进程在之后的某个时候得到调度，它的上下文被换入，占据 CPU，操作系统对fork的实现使得子进程中fork调用返回0，所以在这个进程中pid=0（注意这不是父进程了哦，虽然是同一个程序，但是这是同一个程序的另外一次执行，在操作系统中这次执行是由另外一个进程表示的，从执行的角度说和父进程相互独立）。这个进程在继续执行的过程中，if语句中 pid<0不满足，但是pid==0是true，所以输出：i am the child process…
 
### 3、疑问
为什么看上去程序中互斥的两个分支都被执行了，在一个程序的一次执行中，这当然是不可能的，事实上你看到的两行输出是来自两个独立的进程，而这两个进程来自同一个程序的两次执行。

fork之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，但只有一点不同，如果fork成功，子进程中fork的返回值是0，父进程中fork的返回值是子进程的进程号，如果fork失败，父进程会返回错误。

可以这样想象，2个进程一直同时运行，而且步调一致，在fork之后，他们分别作不同的工作，也就是分岔了，这也是fork为什么叫fork的原因。

至于哪一个进程最先运行，这与操作系统平台的调度算法有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同运作，可以通过控制语法结构的办法解决。
 
fork前子进程可以继承父进程的东西，但是在pcntl_fork()后子进程和父进程就没有任何继承关系了。在子进程里创建的东西是子进程的，在父进程创建的东西是父进程的，可以完全看成是两个独立的进程。

## 三、demo2
```php
$one = 123;
$one++;
$two = time();
$pid = [];
$pid = pcntl_fork();
$three = time();


var_dump($one);
var_dump($three );
echo "\n";
```
输出
int(124)
int(1646643817)

int(124)
int(1646643817)


pcntl_fork()函数执行的时候，会创建一个子进程。子进程会复制当前进程，也就是父进程的所有：数据，代码，还有状态。

1. 当pcntl_fork（）创建子进程成功后，在父进程内，返回子进程号，在子进程内返回0，失败则返回-1

2. 子进程会复制父进程的代码，数据。那么就说明：子，父进程拥有的代码和数据会一模一样。

3. 重点：子进程会复制父进程的状态，那么就有上面的示例代码：在第五行执行了pcntl_fork，那么创建出的子进程，代码也是从第五行开始执行的。又子进程复制了数据，代码。所以，在子进程内同理存在：$one,$two等变量。

```
for ($i = 0; $i < 3; $i++) {
    $pid = pcntl_fork();
}
sleep(30);
```
上面的for循环，实际会产生多少个子进程？答案是7个，在linux下，用ps命令将可以看到8个进程（1个父进程，7个子进程）
原因：父进程在i = 0 时 ， 创 建 出 一 个 子 进 程 0 ， 此 时 的 子 进 程 ， 还 会 继 续 执 行 循 环 。 创 建 出 属 于 自 己 的 子 进 程 。 同 理 ： i=0时，创建出一个子进程0，此时的子进程，还会继续执行循环。创建出属于自己的子进程。同理：i=0时，创建出一个子进程0，此时的子进程，还会继续执行循环。创建出属于自己的子进程。同理：i=1时也会这样……
 

### 4、总结
1. 派生子进程的进程，即父进程，其pid不变；
2. pcntl_fork()函数执行的时候，会创建一个子进程。子进程会复制当前进程，也就是父进程的所有：数据，代码，还有状态。
3. 对子进程来说，fork()函数返回给它0, 但它自身的pid绝对不会是0；之所以fork()函数返回0给它，是因为它随时可以调用getpid()来获取自己的pid；
4. fork之后父、子进程除非采用了同步手段，否则不能确定谁先运行，也不能确定谁先结束。
 

