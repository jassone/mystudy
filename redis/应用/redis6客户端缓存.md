## redis6客户端缓存

## 一、简介
应用缓存通常分两种，本地缓存和远程缓存。本地缓存就是内存缓存 LocalCache，远程缓存就是分布式共享缓存比如 Redis。本地缓存在访问性能上远胜过远程缓存，但是在一致性上要弱一些。我们平时经常会用到的 Guava Cache 就是内存缓存技术框架。

Redis6 提到的「客户端缓存」就是本地缓存。

那 Redis 要对这个「客户端缓存」做到什么程度呢？它如何平衡性能和一致性的问题呢？

## 二、缓存更新机制
Redis6 的这个「客户端缓存」用的是**主动通知客户端** —— 你的数据过时了，请赶快刷新。

Redis 有一个 Pub/Sub 的订阅更新能力是不是可以实现这个小需求，何必要大张旗鼓发明「客户端缓存」这个新概念呢？

下面来看一下 Redis 提供的 Pub/Sub 如何才能做到这一点呢？有两种方式：

### 1、使用自定义的 channel
当远程缓存变化时，修改方（业务进程中的生产方）需要执行 Publish 指令。消费方订阅这个 channel，收到消息时刷新本地缓存。

缺点
* 生产和消费就有了一定程度的耦合，消费者能不能及时刷新缓存取决于生产者有没有配合 Publish 消息。
* 每个更改数据的应用程序查询都需要使用PUBLISH命令，这会使数据库花费更多的CPU时间来处理该命令。
* 每个业务点需要一个独立的不一样的 channel 名称，不能混淆。
* 还有这样的模式会向应用程序中的每个客户端发送无效消息，即使某些客户端可能没有无效数据的任何副本。

### 2、使用Keyspace Notification Event 
使用 Redis 自带的 Keyspace Notification Event 内置的一些 channel。当某个 Key 被删除时，会向 del channel 发送一个 Del 事件。当某个 Key 过期时，会向 expire channel 发送一个 Expire 事件 。会有非常多的内置 channel。当某个 Key 被 Set 时，会向  set channel 发送一个 Set 事件等等。这里的问题在于客户端需要监听处理很多的 内置channel 才能知道内存缓存关联的那个 Redis Key 值是否发生了变化。如果开启了 Keyspace Notification Event，事件发生的太频繁了，Redis 的性能也会受到显著的影响。除此之外，这里还存在一个明显的**惊群问题**，我不想关心的事件 Redis 也会通知给我，因为这里的内置 channel 是所有 key 共享的，任意的 key 发生的变化，channel 的消费者都能收到相应的事件。

### 3、Redis6 的设计方案
Redis6 对「客户端缓存」进行了重新设计，让它使用起来更加方便而且不会显著导致 Redis 本身的性能下降。有了「客户端缓存」，Redis 服务器本身的访问压力也会显著减轻，应用程序只需要访问本地内存就可以得到期望的数据，如此 Redis 就可以应用于更高的并发应用场景。

Redis6 将「客户端缓存」称为**「Client Key Tracking」，表示客户端对指定的 Key 感兴趣，它会订阅这些 Key 的修改通知，如果 Key 发生了变化，客户端会立即收到一个「缓存失效」通知。紧接着客户端就会清空并重建本地缓存。**


## 三、使用
### 1、如何订阅
那如何订阅具体的 Key 呢，Redis6 提供了两种方式：
##### a）默认模式
命令：CLIENT TRACKING ON

* **自动订阅**：就是客户端的某个开关打开后，服务器会自动帮助客户端订阅它所读取的所有的 Key。这种自动订阅的方式虽然很方便，在某些特定的场合下可能并不合适。

* **手动订阅**：需要在每一条需要缓存的读 Key 命令之前打上一条特殊的标记表示接下来的这条指令读取的值会缓存在内存里。

    普通追踪模式下的OPT IN模式

    命令：CLIENT TRACKING ON OPTIN

    特点：
    客户端需要显式通过CLIENT CACHING YES命令指定下一个读请求的键需要被追踪（默认情况下不追踪），其他与普通追踪模式相同。

上述两种方式下，服务器会记住给定客户机访问的密钥，并在修改相同的密钥时发送无效消息。**这会消耗服务器端的内存**，但只会为客户端可能在内存中拥有的一组密钥发送无效消息。

优点：
* 只针对特定客户端发送键无效信息。节省服务器端和客户端CPU资源。

缺点：
* 相对于其他模式来说耗费更多服务器端内存，因为需要记住启用普通追踪模式的客户端访问过的所有键。

##### 还有一种方式
普通追踪模式下的OPT OUT模式
命令： CLIENT TRACKING ON OPTOUT

特点：
用户需要显式通过CLIENT CACHING NO指定下一个键不需要追踪（默认情况下追踪），其他与普通追踪模式相同。

##### b）广播模式
命令：CLIENT TRACKING ON BROADCAST PREFIX <PREFIX1> <PREFIX2> …

特点：
* 服务器保存一个键前缀表（Prefix Table）来记录客户端需要追踪的键前缀，而不是记录所有相应的客户端访问过的键。
* 当满足特定键前缀中的任何键被更新时，服务器向所有订阅特定前缀的客户端发送缓存无效信息。

优点：
* 服务器端只需要记住客户端感兴趣的键前缀信息，节省服务器端内存。

缺点：
* 如果特定键前缀中的任何键被更新时，服务器需要向所有订阅该键前缀的客户端发送缓存无效消息。耗费服务器端和客户端CPU及网络资源，并且客户端可能收到很多没有缓存过的键的无效消息。严重影响服务器的性能。

### 2、使用原则
使用 Client Key Tracking 的原则就是读多写少，比如业务系统使用的全局配置参数。
* 变化频繁的 Key 不要本地缓存，缓存刷新过于频繁
* 读频率低的 Key 不要缓存，缓存意义不大

## 四、如何回收订阅呢
假如有大量客户端订阅了客户端缓存，那么服务器最终会存储太多的信息。为此，Redis使用了两个关键思想来限制服务器端的内存使用量，以及处理实现该功能的数据结构的CPU成本：

* 当客户端开启追踪时，服务器端保存一个无效表（Invalidation Table）来记录所有相应客户端读取过的键的信息。当失效表已经包含了最大数量的条目时，如果插入了一个新的键，服务器可以通过假装该键被修改（即使没有修改），并向客户端发送无效消息来逐出旧条目。这样做，它可以回收用于此密钥的内存，即使这将迫使拥有密钥本地副本的客户端将其逐出。

* 在失效表中，我们实际上不需要存储指向客户端结构的指针，这将在客户端断开连接时强制执行垃圾回收过程：相反，我们所做的只是存储客户端ID（每个Redis客户端都有一个唯一的数字ID）。如果一个客户机断开连接，信息将随着缓存槽的失效而逐渐被垃圾回收。

* **只有一个键名称空间**，不区分数据库编号。因此，如果一个客户机正在缓存数据库2中的key foo，而其他一些客户机更改了数据库3中key foo的值，那么仍然会发送一条无效消息。通过这种方式，我们可以忽略数据库编号，从而降低内存使用量和实现复杂性。

