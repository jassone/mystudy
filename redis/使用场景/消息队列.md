## 消息队列

## 一、使用list开发消息队列

- 普通操作需要轮询check list是否有值，但是存在性能开销。

- 上面的操作需要一直调用rpop命令或者lpop命令才可以实现不停的监听且消费消息。为了解决这一问题，redis提供了阻塞命令 brpop和blpop。如果没有元素则阻塞，如果其中一个有元素则从该键中弹出该元素(会按照key的顺序进行读取，可以实现具有优先级的队列)

### 特点：List 其实是属于拉模型

### 缺点

* 不支持重复消费：消费者拉取消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费，即不支持多个消费者消费同一批数据
* 消息丢失：消费者拉取到消息后，如果发生异常宕机，那这条消息就丢失了(不过可以使用BRPOPLPUSH解决)

## 二、发布订阅Pub/Sub

https://www.cnblogs.com/jingzh/p/14721990.html
### 特点： 属于推模型。
### 优点

* 支持发布 / 订阅，支持多组生产者、消费者处理消息
### 缺点
Pub/Sub 最大问题是：丢数据

因为它没有基于任何数据类型，也没有做任何的数据存储，它只是单纯地为生产者、消费者建立数据转发通道，把符合规则的数据，从一端转发到另一端。

如果发生以下场景，就有可能导致数据丢失：
* 消费者下线 
* Redis 宕机，不支持数据持久化 
* 消息堆积，缓冲区溢出，消费者会被强制踢下线(每个消费者订阅一个队列时，会给这个消费者在分配一个缓冲区，这个缓冲区其实就是一块内存)

注意：消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失

## 三、Redis中的Stream

## 四、zset

需要不断轮询去查询符合条件的数据。 









