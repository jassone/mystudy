## redis性能
redis 瓶颈在于机器的内存、网络IO操作。

## 一、redis性能问题分类

### 1、请求在server中延迟较久
1. 操作bigkey写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时；
2. 使用复杂度过高的命令例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据；
3. **大量key集中过期Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；**
4. 淘汰策略淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
5. AOF刷盘开启always机制每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
6. 主从全量同步生成RDB虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；

##### 解决方案
* 针对1-6问题，一方面需要业务人员去规避。
* Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

### 2、无法利用到CPU多核
并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，**但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。**

针对这个问题，Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能，当然，**只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。**

## 二、redis性能相关数据
### 1、指标
* 输入和输出size超过1k  ,tps下降明显
* hgetall 使用不要超过3K

### 2、key类型 field数量删除耗时
* Hash~100万~1000ms
* List~100万~1000ms
* Set~100万~1000ms
* Sorted Set~100万~1000ms