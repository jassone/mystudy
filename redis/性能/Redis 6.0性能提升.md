## Redis 6.0性能提升

**Redis 6.0采用多个IO线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。使用Redis多线程就可以分摊Redis同步读写I/O的压力，以及充分利用多核CPU资源，进而提升整体性能（提升qps）。**

![85be37f7f8_1440w.jpeg](https://pic.imgdb.cn/item/625bc676239250f7c5b1715c.jpg)

那么多并发的线程安全问题存在吗？——当然不存在。

**Redis 的多 IO 线程只是用来处理网络请求的，对于命令的执行，Redis 仍然使用单线程来处理。这样就没有多线程数据的竞争关系，依然很高效。**

### 1、大致流程

利用多核来分担I/O读写负荷。在事件处理线程每次获取到可读事件时，会将所有就绪的读事件分配给I/O线程，并进行等待，在所有I/O线程完成读操作后，事件处理线程开始执行任务处理，在处理结束后，同样将写事件分配给I/O线程，等待所有I/O线程完成写操作。

在Redis中虽然使用了I/O多路复用，并且是基于非阻塞I/O进行操作的，但是**I/O的读和写本身是阻塞的**。而且这些操作都是基于单线程完成的。

多个IO线程读取网络请求后，将所有请求内容放到内存中，统一由主线程进行处理，主线程处理完成后，将所有响应内容交给多个IO线程，IO线程再负责发送响应到客户端。

它的主要实现思路是**将主线程的I/O读写任务拆分给一组独立的线程去执行，这样就可以使多个socket的读写并行化了，但Redis的命令依旧是由主线程串行执行的。**

### 2、具体流程分为以下 4 阶段：
* 阶段⼀：服务端和客⼾端建立 Socket 连接，并分配处理线程，当有客⼾端请求和实例建立 Socket 连接时，主线程会创建和客户端的连接，并把 Socket 放入全局等待队列中。然后主线程通过轮询方法把 Socket 连接分配给 IO 线程。

* 阶段⼆：IO 线程读取并解析请求，主线程把 Socket 分配给 IO 线程后，会进⼊阻塞状态等待 IO 线程完成客户端请求读取和解析。

* 阶段三：主线程执⾏请求操作IO 线程解析完请求后，主线程以单线程的⽅式执⾏这些命令操作。

* 阶段四：IO 线程回写 Socket 和主线程清空全局队主线程执行完请求操作后，会把需要返回的结果写入缓冲区。然后，主线程会阻塞等待 IO 线程把这些结果回写到 Socket 中，并返回给客户端。等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。


### 3、局限性
从上面实现上看，6.0版本的多线程并非彻底的多线程，I/O线程只能同时执行读或者同时执行写操作，期间事件处理线程一直处于等待状态，并非流水线模型，有很多轮训等待开销。

## 二、配置
在 Redis6.0 中，多线程机制默认是关闭的，需要在 redis.conf 中完成以下两个设置才能启用多线程。设置 io-thread-do-reads 配置项为 yes，表示启用多线程。

```sh
io-threads-do-reads yes
```

设置线程个数。⼀般来说，线程个数要小于 Redis 实例所在机器的 CPU 核数，例如，对于⼀个 8 核的机器来说，Redis 官⽅建议配置 6 个 IO 线程。
```sh
io-threads 6
```


## 相关wiki
* 正式支持多线程！Redis 6.0与老版性能对比评测 https://zhuanlan.zhihu.com/p/76788470
* Redis 6.0 新特性 https://blog.csdn.net/qq_18298439/article/details/106019983
* 支持多线程的Redis6.0来了  https://www.cnblogs.com/mr-wuxiansheng/p/12884356.html
* redis 6.0多线程的实现原理是什么？ https://www.cxyxiaowu.com/21108.html
* Redis是属于多线程还是单线程？不同版本之间有什么区别？https://blog.csdn.net/seanxwq/article/details/115205169