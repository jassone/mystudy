## redis的单线程和多线程

Redis 是基于 Reactor 单线程模式来实现的。

IO多路复用程序接收到用户的请求后，全部推送到一个队列里，交给文件分派器。对于后续的操作，和在 reactor 单线程实现方案里看到的一样，整个过程都在一个线程里完成，因此 Redis 被称为是单线程的操作。

![2GHJHGFER.jpeg](https://pic.imgdb.cn/item/625bfbdf239250f7c50f8683.jpg)

## 一、redis的单线程模型
**Redis的单线程指的是执行命令时的单线程。所以可以被用来做分布锁。**

一条命令从从客户端达到服务端不会立刻被执行，而是会进入一个队列中等待，每次只会有一条指令被选中执行。

发送命令、返回结果、命令排队这些就不是那么简单了，例如Redis使用了I/O多路复用技术(epoll)来解决I/O的问题。

### 1、Redis为什么要使用单线程
官方解释
* 因为Redis是基于内存的操作，CPU成为Redis的瓶颈的情况很少见，Redis的瓶颈最有可能是内存的大小或者网络限制。

* 如果想要最大程度利用CPU，可以在一台机器上启动多个Redis实例，配置到不同端口上 
    ```sh
    ./redis-server redis.conf
    ```

其实就是历史原因，开发者嫌多线程麻烦，后来这个CPU的利用问题就被抛给了使用者。

其他人的解释
* 没有任何的外部IO(DB操作，kv查询，外部接口调用，磁盘IO)，纯内存读写。所以**即使单线程qps也是非常快的**。
* 接收命令，返回结果，命令排队等，用的是‘异步IO’(epoll)

所以在这种情况下，CPU不会因为IO阻塞而空闲，单线程已经充分利用了CPU.

### 2、redis单线程为什么那么快
通常来讲，单线程处理能力要比多线程差，那么为什么Redis使用单线程模型会达到每秒万级别的处理能力呢？可以将其归结为三点：

1. **纯内存访问**，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的最重要的基础。
2. **Reactor模式的网络事件处理器，异步非阻塞I/O**，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。
3. **单线程避免了线程切换和竞态产生的消耗**。

    **在多线程开发中，存在线程的切换和竞争，这样一来，是有时间的消耗的。**对于需要磁盘I/O的程序来讲，磁盘I/O是一个比较耗时的操作，所以对于需要进行磁盘I/O的程序，我们可以使用多线程，在某个线程进行I/O时，CPU切换到当前程序的其他线程执行，以此减少CPU的等待时间。
    
    那么问题来了。Redis的数据存放在内存中，将内存中的数据读入CPU时，CPU不是依然需要等待吗，为什么不能在等待数据从内存读入CPU期间执行其他线程，以此提高CPU的使用率呢？这个问题的答案很简单，**内存的读写速度虽然比CPU慢很多，但是也是非常快的。CPU切换线程需要花费一定的时间，而多次切换线程所花费的时间，可能比直接使用单线程执行相同的任务，花费的时间要更多，这是非常不划算的。**  
    
   **单线程也会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库。**

其他原因
1. Redis使用RESP 协议，将数据的长度放在数据正文之前， 所以程序无须像 JSON 那样， 为了寻找某个特殊字符而扫描整个payload ， 也无须对发送至服务器的payload 进行转义。
2. 简单高效的基础数据结构：动态字符串（SDS），链表，字典，跳跃链表，整数集合和压缩列表。然后 redis 在这个基础上去实现用户能操作的对象：字符串，列表，哈希，集合，有序集合等对象。

## 二、redis 的单多线程的改版过程
### 1、3.0的改版
Redis 3.0 版本后，主进程中除了主线程处理网络 IO 和命令操作外，还有 3 个辅助 BIO(Background I/O) 线程。他们分别是fsync线程(AOF缓冲数据刷新到磁盘)、close线程(文件关闭)、清理回收线程，从而避免这些任务对主 IO 线程的影响。

Redis 在启动时，会同时启动这三个 BIO 线程，但是 BIO 线程只有在需要执行相关类型后台任务时才会唤醒，其他时间会休眠等待任务。

##### 多进程
除了主进程，在以下场景如果需要进行重负荷任务的处理，Redis 会 fork 一个子进程来处理：
* 收到 bgrewriteaof 命令：Redis fork 一个子进程，然后子进程往临时 AOF文件中写入重建数据库状态的所有命令。写入完毕后，子进程会通知父进程把新增的写操作追加到临时 AOF 文件。最后将临时文件替换旧的 AOF 文件，并重命名。
* 收到 bgsave 命令：Redis 构建子进程，子进程将内存中的所有数据通过快照做一次持久化落地，写入到 RDB 中。
* 当需要进行全量复制：master 启动一个子进程，子进程将数据库快照保存到 RDB 文件。在写完 RDB 快照文件后，master 会把 RDB 发给 slave，同时将后续新的写指令都同步给 slave。

### 2、4.0的改版
单线程的设计也给Redis带来一些问题：
* 只能使用CPU一个核；
* 如果删除的键过大（比如Set类型中有上百万个对象），会导致服务端阻塞好几秒；
* QPS难再提高。

**所以从4.0版本开始引入Lazy Free(惰性删除，也叫异步删除)，底层处理是多线程的，可以开后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、unlink命令删除大key、flushdb async、flushall async等。**

而AOF、RDB这些操作都是创建子进程，不是线程。

##### Lazy Free机制
Redis在处理客户端命令时是以单线程形式运行，而且处理速度很快，期间不会响应其他客户端请求，但若客户端向Redis发送一条耗时较长的命令，比如删除一个含有上百万对象的Set键，或者执行flushdb，flushall操作，Redis服务器需要回收大量的内存空间，导致服务器卡住好几秒，对负载较高的缓存系统而言将会是个灾难。为了解决这个问题，在Redis 4.0版本引入了Lazy Free，将慢操作异步化，这也是在事件处理上向多线程迈进了一步。

要解决慢操作，可以采用渐进式处理，即增加一个时间事件，比如在删除一个具有上百万个对象的Set键时，每次只删除大键中的一部分数据，最终实现大键的删除。但是，该方案可能会导致回收速度赶不上创建速度，最终导致内存耗尽。因此，**Redis最终实现上是将大键的删除操作异步化，采用非阻塞删除（对应命令UNLINK），大键的空间回收交由单独线程实现，主线程只做关系解除，可以快速返回，继续处理其他事件，避免服务器长时间阻塞。**

### 3、6.0的改版
目前对于单线程 Redis 来说，**读写网络的 Read/Write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗**。优化主要有两个方向:
* 提高网络 IO 性能，典型的实现像使用 DPDK 来替代内核网络栈的方式。
* 使用多线程充分利用多核，典型的实现像 Memcached。

Redis6.0引入了IO线程，负责读、写网络IO-多线程的特性，这个多线程是在哪里呢？——**是对处理网络请求过程采用了多线程，利用多核来分担I/O读写负荷。进而提升QPS。**。

> 总之:redis的worker是单线程的

## 三、redis QPS/TPS
### 1、QPS
* 据官方数据表示Redis读的速度是110000次/s,写的速度是81000次/s
* 但是5w qps可能就达到极限了。

### 2、TPS
对于机械硬盘，Redis只能支持大约几百TPS写入；固态硬盘（SSD）,每秒大约也只能处理几万个命令.

## 相关wiki
* 为什么 Redis 选择单线程模型 https://draveness.me/whys-the-design-redis-single-thread/
* Redis 和 I/O 多路复用 https://draveness.me/redis-io-multiplexing/
* Redis为什么是单线程的 https://www.debugger.wiki/article/html/1588496434080602 
