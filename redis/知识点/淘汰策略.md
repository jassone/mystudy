## Redis淘汰策略
## 一、淘汰策略分类
##### 默认策略
* noeviction：当设置的内存空间用完时，不再提供写请求服务，直接返回错误（DEL请求和部分特殊请求除外）。

##### ttl策略
* volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰

##### lru策略
* allkeys-lru：从所有key中使用LRU算法进行淘汰

* volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰

##### lfu策略
* volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键

* allkeys-lfu：从所有键中驱逐使用频率最少的键

##### 随机策略
* allkeys-random：从所有key中随机淘汰数据

* volatile-random：从设置了过期时间的key中随机淘汰

当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误

## 二、淘汰算法-LRU算法 
LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法。

其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。

### LRU在Redis中的实现
Redis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。

```
struct redisServer {
       pid_t pid; 
       char *configfile; 
       //全局时钟
       unsigned lruclock:LRU_BITS; 
       ...
};
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    /* key对象内部时钟 */
    unsigned lru:LRU_BITS;
    int refcount;
    void *ptr;
} robj;
```

### 近似LRU算法
Redis中的LRU与常规的LRU实现并不相同，常规LRU会准确的淘汰掉队头的元素，但是Redis的LRU并不维护队列，只是根据配置的策略要么从所有的key中随机选择N个（N可以配置）要么从所有的设置了过期时间的key中选出N个键，然后再从这N个键中选出最久没有使用的一个key进行淘汰。

Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。

##### Redis3.0对近似LRU的优化
Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中。

随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。

当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。

当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。

##### LRU算法的对比
我们可以通过一个实验对比各LRU算法的准确率，先往Redis里面添加一定数量的数据n，使Redis可用内存用完，再往Redis里面添加n/2的新数据，这个时候就需要淘汰掉一部分的数据

如果按照严格的LRU算法，应该淘汰掉的是最先加入的n/2的数据。

生成如下各LRU算法的对比图：
![05761D23-00BB-453D-A3C7-5F0102EF0760.png](https://pic.imgdb.cn/item/618e75af2ab3f51d91006a2b.png)
你可以看到图中有三种不同颜色的点：

* 浅灰色是被淘汰的数据

* 灰色是没有被淘汰掉的老数据

* 绿色是新加入的数据

从图中可以看出，在redis 3中，设置样本数为10的时候能够很准确的淘汰掉最久没有使用的键，与常规LRU基本持平。

##### 为什么要使用近似LRU？
1. 性能问题，由于近似LRU算法只是最多随机采样N个key并对其进行排序，如果精准需要对所有key进行排序，这样近似LRU性能更高

2. 内存占用问题，redis对内存要求很高，会尽量降低内存使用率，如果是抽样排序可以有效降低内存的占用

3. 实际效果基本相等，如果请求符合长尾法则，那么真实LRU与Redis LRU之间表现基本无差异

4. 在近似情况下提供可自配置的取样率来提升精准度，例如通过 CONFIG SET maxmemory-samples <count> 指令可以设置取样数，取样数越高越精准，如果你的CPU和内存有足够，可以提高取样数看命中率来探测最佳的采样比例。

## 三、淘汰算法-LFU算法
LFU算法是`Redis4.0`里面新加的一种淘汰策略。它的全称是Least Frequently Used。

因为LRU的最近最少使用实际上并不精确，考虑下面的情况，如果在|处删除，那么A距离的时间最久，但实际上A的使用频率要比B频繁，所以合理的淘汰策略应该是淘汰B。LFU就是为应对这种情况而生的。

A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|

B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~~B|


它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。

LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。

如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。

### LFU在Redis中的实现
LFU把原来的key对象的内部时钟的24位分成两部分，前16位还代表时钟，后8位代表一个计数器。16位的情况下如果还按照秒为单位就会导致不够用，所以一般这里以时钟为单位。而后8位表示当前key对象的访问频率，8位只能代表255，但是redis并没有采用线性上升的方式，而是通过一个复杂的公式，通过配置如下两个参数来调整数据的递增速度。

lfu-log-factor 可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。

lfu-decay-time 是一个以分钟为单位的数值，可以调整counter的减少速度。

所以这两个因素就对应到了LFU的Counter减少策略和增长策略，它们实现逻辑分别如下。

##### 新生KEY策略
另外一个问题是，当创建新对象的时候，对象的counter如果为0，很容易就会被淘汰掉，还需要为新生key设置一个初始counter。counter会被初始化为LFU_INIT_VAL，默认5。

## 三、淘汰策略选择
* 如果分为热数据和冷数据，推荐使用allkeys-lru策略，也就是，其中一部分key经常被读写。
* 如果不确定具体的业务特征，那么allkeys-lru是一个很好的选择。
* 如果需要循环读写所有的key,或者各个key的访问频率差不多，可以使用allkeys-random策略，即读写所有的元素的概率差不多。
* 假如要让Redis根据ttl来筛选需要删除的key,请使用volatile-ttl策略。

* volatile-lru和volatile-random策略主要应用场景是：既有缓存，又有持久key的实例中，一般来说，像这类场景，应该使用两个单独的Redis实例。
* 值得一提的是，设置expire会消耗额外的内存，所以使用allkeys-lru策略，可以更高效的利用内存，因为这样就可以不再设置过期时间了。

## 四、相关查询和配置
### 1 如何获取及设置内存淘汰策略
获取当前内存淘汰策略：

```sh
127.0.0.1:6379> config get maxmemory-policy
```

通过配置文件设置淘汰策略（修改redis.conf文件）：
```ini
maxmemory-policy allkeys-lru
```

通过命令修改淘汰策略：
```sh
127.0.0.1:6379> config set maxmemory-policy allkeys-lru
```

### 2 配置Redis能使用的最大的内存大小
1、通过配置文件配置
redis.conf配置文件中添加以下配置设置内存大小
```ini
//设置Redis最大占用内存大小为100M
maxmemory 100mb
```

2、通过命令修改
//设置Redis最大占用内存大小为100M
```sh
127.0.0.1:6379> config set maxmemory 100mb
```

//获取设置的Redis能使用的最大内存大小
```sh
127.0.0.1:6379> config get maxmemory
```

如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存.