### 前言
除了RDB持久化功能以外，Redis还提供了AOF(Append Only File)持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis所执行的写命令来记录数据库状态的。

大致流程
![1](https://pic.imgdb.cn/item/61052c3b5132923bf8a22356.png)

###  AOF持久化
**AOF持久化功能的实现可以分为命令追加、文件写入、文件同步三个步骤**。

##### 命令追加：

当AOF持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

综合起来，整个缓存追加过程可以分为以下三步：
* 接受命令、命令的参数、以及参数的个数、所使用的数据库等信息。
* 将命令还原成 Redis 网络通讯协议。
* 将协议文本追加到 aof_buf 末尾。

##### AOF文件的写入与同步：

每当服务器常规任务函数被执行、 或者事件处理器被执行时， aof.cflushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作：

* WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件。

* SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。

两个步骤都需要根据一定的条件来执行， 而这些条件由 AOF 所使用的保存模式来决定， 以下小节就来介绍 AOF 所使用的三种保存模式， 以及在这些模式下， 步骤 WRITE 和 SAVE 的调用条件。

Redis 目前支持三种 AOF 保存模式，它们分别是：

* AOF_FSYNC_NO ：不保存。

* AOF_FSYNC_EVERYSEC ：每一秒钟保存一次。

* AOF_FSYNC_ALWAYS ：每执行一个命令保存一次。

这三种情况下的 SAVE 操作都会引起 Redis 主进程阻塞。

##### 不保存
在这种模式下， 每次调用 flushAppendOnlyFile 函数， WRITE 都会被执行， 但 SAVE 会被略过。

在这种模式下， SAVE 只会在以下任意一种情况中被执行：
Redis 被关闭
AOF 功能被关闭
系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行），通常同步周期为30秒

##### 每一秒钟保存一次

在这种模式中， SAVE 原则上每隔一秒钟就会执行一次， 因为 SAVE 操作是由后台子线程调用的， 所以它不会引起服务器主进程阻塞。

注意， 在上一句的说明里面使用了词语“原则上”， 在实际运行中， 程序在这种模式下对 fsync 或 fdatasync 的调用并不是每秒一次， 它和调用 flushAppendOnlyFile 函数时 Redis 所处的状态有关。

每当 flushAppendOnlyFile 函数被调用时， 可能会出现以下四种情况：

子线程正在执行 SAVE ，并且：这个 SAVE 的执行时间未超过 2 秒，那么程序直接返回，并不执行 WRITE 或新的 SAVE 。

这个 SAVE 已经执行超过 2 秒，那么程序执行 WRITE ，但不执行新的 SAVE 。注意，因为这时 WRITE 的写入必须等待子线程先完成（旧的） SAVE ，因此这里 WRITE 会比平时阻塞更长时间。

子线程没有在执行 SAVE ，并且：上次成功执行 SAVE 距今不超过 1 秒，那么程序执行 WRITE ，但不执行 SAVE 。

上次成功执行 SAVE 距今已经超过 1 秒，那么程序执行 WRITE 和 SAVE 。

可以用流程图表示这四种情况：

![1](https://pic.imgdb.cn/item/61051b0f5132923bf871421e.png)


根据以上说明可以知道， 在“每一秒钟保存一次”模式下， 如果在情况 1 中发生故障停机， 那么用户最多损失小于 2 秒内所产生的所有数据。

如果在情况 2 中发生故障停机， 那么用户损失的数据是可以超过 2 秒的。

Redis 官网上所说的， AOF 在“每一秒钟保存一次”时发生故障， 只丢失 1 秒钟数据的说法， 实际上并不准确。

##### 每执行一个命令保存一次

在这种模式下，每次执行完一个命令之后， WRITE 和 SAVE 都会被执行。

另外，因为 SAVE 是由 Redis 主进程执行的，所以在 SAVE 执行期间，主进程会被阻塞，不能接受命令请求。

AOF 保存模式对性能和安全性的影响

在上一个小节， 我们简短地描述了三种 AOF 保存模式的工作方式， 现在， 是时候研究一下这三个模式在安全性和性能方面的区别了。

对于三种 AOF 保存模式， 它们对服务器主进程的阻塞情况如下：

**不保存（AOF_FSYNC_NO）**：写入和保存都由主进程执行，两个操作都会阻塞主进程。

**每一秒钟保存一次**（AOF_FSYNC_EVERYSEC）：写入操作由主进程执行，阻塞主进程。保存操作由子线程执行，不直接阻塞主进程，但保存操作完成的快慢会影响写入操作的阻塞时长。

**每执行一个命令保存一次**（AOF_FSYNC_ALWAYS）：和模式 1 一样。

因为阻塞操作会让 Redis 主进程无法持续处理请求， 所以一般说来， 阻塞操作执行得越少、完成得越快， Redis 的性能就越好。

模式 1 的保存操作只会在AOF 关闭或 Redis 关闭时执行， 或者由操作系统触发， 在一般情况下， 这种模式只需要为写入阻塞， 因此它的写入性能要比后面两种模式要高， 当然， 这种性能的提高是以降低安全性为代价的： 在这种模式下， 如果运行的中途发生停机， 那么丢失数据的数量由操作系统的缓存冲洗策略决定。

模式 2 在性能方面要优于模式 3 ， 并且在通常情况下， 这种模式最多丢失不多于 2 秒的数据， 所以它的安全性要高于模式 1 ， 这是一种兼顾性能和安全性的保存方案。

模式 3 的安全性是最高的， 但性能也是最差的， 因为服务器必须阻塞直到命令信息被写入并保存到磁盘之后， 才能继续处理请求。

综合起来，三种 AOF 模式的操作特性可以总结如下：

| 命令 |write是否阻塞|save是否阻塞| 优点 | 缺点 |停机时丢失的数据量|
| --- |---| --- |--- | --- |--- |
|  no|是| 是| 不用管| 不可控 |操作系统最后一次对AOF文件触发save操作之后的数据|
|  everysec|是|否|  每秒进行与fsync|  最多丢失2秒数据|最多丢失2秒数据|
| always |是|是|不丢失数据  |  IO开销大，一般SATA磁盘只有几百TPS|最多丢失一个命令数据|

推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。


### AOF 文件的读取和数据还原
大致流程
![1](https://pic.imgdb.cn/item/61052cab5132923bf8a349f5.png)

AOF 文件保存了 Redis 的数据库状态， 而文件里面包含的都是符合 Redis 通讯协议格式的命令文本。

这也就是说， 只要根据 AOF 文件里的协议， 重新执行一遍里面指示的所有命令， 就可以还原 Redis 的数据库状态了。

文件校验：载入AOF文件时会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启(默认开启)，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功(否则需要手动执行redis-check-aof)。

Redis 读取 AOF 文件并还原数据库的详细步骤如下：

1. 创建一个不带网络连接的伪客户端（fake client）。

2. 读取 AOF 所保存的文本，并根据内容还原出命令、命令的参数以及命令的个数。

3. 根据命令、命令的参数和命令的个数，使用伪客户端执行该命令。

4. 执行 2 和 3 ，直到 AOF 文件中的所有命令执行完毕。

完成第 4 步之后， AOF 文件所保存的数据库就会被完整地还原出来。

注意，因为 Redis 的命令只能在客户端的上下文中被执行，而 AOF 还原时所使用的命令来自于 AOF 文件，而不是网络，所以程序使用了一个没有网络连接的伪客户端来执行命令。伪客户端执行命令的效果，和带网络连接的客户端执行命令的效果完全一样。

##### AOF重写

因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，随着服务器运行时间的流逝，AOF文件中的文件体积越来越大，如果不加以控制，会对redis服务器甚至宿主计算器造成影响。

所谓的“重写”其实是一个有歧义的词语， 实际上， AOF 重写并不需要对原有的 AOF 文件进行任何写入和读取， 它针对的是数据库中键的当前值。

考虑这样一个情况， 如果服务器对键 list 执行了以下四条命令：
```
RPUSHlist1234// [1, 2, 3, 4]
RPOPlist// [1, 2, 3]
LPOPlist// [2, 3]
LPUSHlist1// [1, 2, 3]
```
那么当前列表键 list 在数据库中的值就为 [1, 2, 3] 。

如果我们要保存这个列表的当前状态， 并且尽量减少所使用的命令数， 那么最简单的方式不是去 AOF 文件上分析前面执行的四条命令， 而是直接读取 list 键在数据库的当前值， 然后用一条 RPUSH 1 2 3 命令来代替前面的四条命令。

除了列表和集合之外， 字符串、有序集、哈希表等键也可以用类似的方法来保存状态， 并且保存这些状态所使用的命令数量， 比起之前建立这些键的状态所使用命令的数量要大大减少。

AOF重写程序aof_rewrite函数可以很好完成创建一个新AOF文件的任务，但是这个函数会进行大量写入操作，会长时间阻塞，所以Redis将AOF重写程序放到子进程里执行，这样做达到两个目的：

1. 子进程AOF重写期间，服务器进程可以继续处理命令请求。

2. 子进程带有数据库进程的数据副本，使用子进程而不是线程，可以避免使用锁的情况下保证数据安全。

#####  整个流程
![1](https://pic.imgdb.cn/item/6105eecb5132923bf8331643.png)

* Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。这个主要是基于性能方面的考虑。

* **父进程执行fork操作创建子进程，这个过程中父进程是阻塞的**。

* 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。

* 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令**同时追加到aof_buf和aof_rewirte_buf两个缓冲区**。子进程根据内存快照，按照命令合并规则写入到新的AOF文件。

* 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。

* 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。

* 使用新的AOF文件替换老文件，完成AOF重写。

##### AOF重写缓冲区流程
![1](https://pic.imgdb.cn/item/61052e555132923bf8a7d2e0.png)

这个信号函数执行完毕以后，父进程就可以继续像往常一样接受命令请求了，在整个AOF后台重写过程中，只有**信号处理函数执行时会对服务器进程造成阻塞**，其他时候都可以继续处理请求，这样AOF重写对服务器性能造成的影响降到了最低。

以上就是AOF后台重写，也即是BGREWRITEAOF命令的实现原理。

##### 重写能够压缩AOF文件原因在于：
* 过期的数据不再写入文件
* 无效的命令不再写入文件，有些数据被删除了等等
* 多条命令可以合并为一个，不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、hash、set、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64

##### AOF 后台重写的触发条件
AOF 重写可以由用户通过调用 BGREWRITEAOF 手动触发。**在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行**。

另外， 服务器在 AOF 功能开启的情况下， 会维持以下三个变量：
* 记录当前 AOF 文件大小的变量 aof_current_size 。
* 记录最后一次 AOF 重写之后， AOF 文件大小的变量 aof_rewrite_base_size 。
* 增长百分比变量 aof_rewrite_perc 。

每次当 serverCron 函数执行时， 它都会检
查以下条件是否全部满足， 如果是的话， 就会触发自动的 AOF 重写：

* 没有 BGSAVE 命令在进行。
* 没有 BGREWRITEAOF 在进行。
* 当前 AOF 文件大小大于 server.aof_rewrite_min_size （默认值为 1 MB）。
* 当前 AOF 文件大小和最后一次 AOF 重写后的大小之间的比率大于等于指定的增长百分比。
默认情况下， 增长百分比为 100% ， 也即是说， 如果前面三个条件都已经满足， 并且当前 AOF 文件大小比最后一次 AOF 重写时的大小要大一倍的话， 那么触发自动 AOF 重写。


#####  AOF的优点
* 使用AOF 会让你的Redis更加耐久: 你可以使用不同的fsync策略：无fsync，每秒fsync，每次写的时候fsync。使用默认的每秒fsync策略，Redis的性能依然很好(fsync是由后台线程进行处理的，主线程会尽力继续处理客户端请求)，一旦出现故障，你最多丢失2秒的数据。
* AOF文件是一个只进行追加的日志文件，所以不需要写入seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用redis-check-aof工具修复这些问题。
* Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。
* AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。

##### AOF的缺点
* 对于相同的数据集来说，AOF文件的体积通常要大于 RDB文件的体积。

* 根据所使用的Fsync策略，AOF的速度可能会慢于 RDB。在一般情况下，每秒Fsync的性能依然非常高，而关闭 Fsync可以让 AOF的速度和 RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间(Latency)。


### AOF相关配置
```
# 开启AOF持久化方式
appendonly yes

# AOF持久化文件名
appendfilename appendonly-<port>.aof

# 每秒把缓冲区的数据同步到磁盘
appendfsync everysec

# 数据持久化文件存储目录
dir /var/lib/redis

# 是否在执行重写时不同步数据到AOF文件
# 这里的 yes，就是执行重写时不同步数据到AOF文件
no-appendfsync-on-rewrite yes

# 触发AOF文件执行重写的最小尺寸
auto-aof-rewrite-min-size 64mb

# 触发AOF文件执行重写的增长率
auto-aof-rewrite-percentage 100

如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件
aof-load-truncated yes
```
