## bitmap使用场景和原理
## 一、bitmap的原理、用法
* bitmap就是通过**计算机存储最小的单位bit**来进行0或者1的设置值或状态，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。
* 相关key: setBit getbit bitcount bitop

## 二、bitmap的优势、限制
### 1、优势
* 基于最小的单位bit进行存储，所以非常省空间。
* 设置时候时间复杂度O(1)、读取时候时间复杂度O(n)，操作是非常快的。
* 二进制数据的存储，进行相关计算的时候非常快。
* 方便扩容
* <font color="red">多维交叉计算能力</font>

### 2、限制
redis中bit映射被限制在512MB之内，所以最大是2^32位。建议每个key的位数都控制下，因为读取时候时间复杂度O(n)，越大的串读的时间花销越多。
 
## 三、bitmap的使用场景
### 1、一种是某一用户的横向扩展
即此个key值中记录这当前用户的各种状态值，允许无限扩展(2^32内)

点评：这种用法基本上是很少用的，因为每个key携带uid信息，如果存储的key的空间大于value，从空间角度看有一定的优化空间，如果是记录长尾的则可以考虑。

### 2、一种是某一用户的纵向扩展
即每个key只记录当前业务属性的状态，每个uid当作bit位来记录信息(用户超过2^32内需要分片存储)

点评：基本上项目使用的场景都是基于这种方式的，按业务区分方便回收资源，key值就一个，将uid的存储转为了位的存储，十分巧妙的通过uid即可找到相应的值，主要存储量在value上，符合预期。（**因为普通方式是根据业务属性＋uid为key来存储。读写效率角度没毛病，但是存储的角度来说key的数据量都大于value了，太耗费空间了**）
 
## 四、bitmap的使用场景案例
* 用户签到(key 为用户日期或者从上线开始那天算第几天)
* 统计活跃用户(key 为用户uid)
 
## 五、Bitmap 压缩技术
* 而常见的压缩技术都是基于 RLE（Run Length Encoding）
* 000000111100000 -> 0545
* 对于一个很大的 Bitmap，如果里边的数据分布很稀疏（说明有很多大片连续的 0），优势很大
* 同时引入一些对齐的技术，可以让采用 RLE 编码的 Bitmap 不需要进行解压缩，就可以直接进行 AND/OR/XOR 等各类计算。

## 六、bitmap优化
* 这时引入**内存映射文件**来解决大bitmap存储mysql的读取问题
* 分布式 Bitmap 计算(把复杂的多维交叉分析，分解成很多小单元计算，分配到不同的服务器上计算，再做汇总计算得到结果)

## 七、bitmap 底层
* Redis本身的bitcount会根据字符串长度自动选择variable-precision SWAR还是查表法。

## 八、相关wiki
* Redis中BitMap是如何储存的，以及PHP如何处理 https://segmentfault.com/a/1190000008205145
