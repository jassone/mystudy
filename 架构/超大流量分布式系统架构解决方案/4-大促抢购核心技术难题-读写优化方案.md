## 大促抢购核心技术难题-读写优化方案

热点数据的大并发读写操作，一直是秒杀、限时抢购等场景下的2个技术难题。这种场景下的热点数据导致的单点瓶颈已经不再是简单通过水平扩容就能解决的。

* 热点数据的读操作，尽管通过分布式缓存来提升系统的QPS，但是缓存系统的单点容量还是存在上限，

* 热点数据的写操作，势必会下潜到数据库，引起大量的线程相互竞争Innodb的行锁，并发越大，等待的线程就越多。

## 一、缓存方案
### 1、CDN缓存

### 2、本地缓存
比如Ehcache。

##### a) 本地缓存痛点
* 占用系统的内存资源
* 数据一致性问题

所以推荐使用分布式缓存，只有当分布式缓存存在单点问题时，才建议结合本地缓存组合使用。

##### b) off-heap技术
用来规避资源占用率较高和频繁GC的问题。
todo

### 3、分布式缓存
高性能的redis。

## 二、同一热卖商品并发读难题-方案
### 1、多级缓存方案
参考“多级缓存的分层架构”章节。

理论上只缓存以下两类数据
* 商品详情数据
* 商品库存(但是要几秒钟后去拉取最新的库存数据)

##### a）这种设计很可能会出现超卖情况啊
其实对于读场景，可以接受一定程度的脏数据，等到最终下单时再去验证是否还有库存即可。

##### b) 缓存穿透思考
如何配置热点key呢？
建议将热点key存放在配置中心内，便于管理。同时在大促活动开始前，从运营那里拿到所有热卖商品的热点key。

### 2、RedisCluster模式-一主多从读/写分离方案
master节点对应的slave节点越多，整体的QPS就越强。

## 三、同一热卖商品并发写难题-方案
### 1、Innodb的行锁问题
很少有人用Innodb的悲观锁，性能太差。

还有一种乐观锁的方案，详见“通过乐观锁解决并发数据冲突”章节。

秒杀商品库存较少，实际落到数据库中的写操作很少，只要系统上游做好限流措施，一般数据库压力不会很大。

但如果是大库存的限时抢购就相反了，大并发写不可避免，**这时候建议将热卖商品的库存扣减操作转移至外部进行。**

### 2、基于redis乐观锁的库存扣减方案
##### a) 方案1：分布式锁
但是太重。效率提不上来。

##### b) 基于乐观锁实现库存扣减
将watch/multi/exec等命令相结合，如下：
![6D5D.png](https://pic.imgdb.cn/item/62b080970947543129569ac6.png)

如果执行库存减少操作能成功，说明商品库存数量没有被变更。

问题：**同一热卖商品并发写操作越高，其watch的碰撞概率就越大。同时库存扣减的成功率也就越低。**

##### c) 嵌入lua脚本的库存扣减方案
![-68D1B1F7E896.png](https://pic.imgdb.cn/item/62b084d509475431295d0500.png)

这是对上面方案的改进，优点：
* 可以提高库存扣减成功率，只要商品未售罄，就一定能扣减成功。避免watch方式的碰撞问题。
* 整体只要redis请求一次，降低网络开销。

## 四、基于AliSql数据库提升并发写特性





