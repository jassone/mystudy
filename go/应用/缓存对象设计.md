## 缓存对象设计

## 一、存储对象

- 字节缓存：[]byte + 用于定位的map[int]int，**瓶颈在序列化开销**。
- 对象缓存：map[interface{}]interface{}，**瓶颈在GC开销**。

为什么字节缓存不是：[]string或map[int]string？

因为如果一个map中不包含指针，可以避免GC扫描。

### 1、两种缓存，如何选择

- 少量大对象 => 对象缓存
- 大量对象 => 字节缓存

经验：缓存条目较多时，尤其是包含复杂结构体时(比如上面map里的value的结构体，放了各种类型的变量)，对象缓存严重影响GC性能。

### 2、对内存的控制

- 字节缓存可以教精确的控制内存占用
- 对象缓存只能通过控制对象数量间接控制内存占用

## 二、缓存策略

### 1、考虑的点

- 逐出策略
- 锁
- 存储对象

一些第三方库

![20221125154102.jpg](https://pic.imgdb.cn/item/638080a216f2c2beb19f27a8.jpg)

## 三、序列化

将go对象转化为[]byte

### 1、考虑的点

- 可读性
- 性能：GC
- 包大小
- 易用性

一些序列化组件

![20221125164927.jpg](https://pic.imgdb.cn/item/6380825a16f2c2beb1a1d2b8.jpg)

## 四、回源

### 1、抽象

##### a) 需要适配跟多的数据源，函数签名保持一致。

##### b）不跟类型绑定，采用interface+reflect

和类型相关的部分：

- 生成缓存的key
- 回源函数的参数
- 最终结果

