## go 互斥锁mutex的实现
Mutex(Mutual exclusion):互斥体，互斥锁。

## 一、mutex的数据结构
### 1、mutex结构体
```go
go type Mutex struce{
    state int32 
    sema uint32 
}
```
* state表示互斥锁的状态，比如是否被锁定
* sema表示**信号量**，解锁的协程释放该信号量来唤醒协程阻塞队列，即协程阻塞队列等待该信号量来唤醒协程，

### 2、mutex的内存布局
![v2-81c5ca390589108229ed873e7648c06e_1440w.jp](https://pic.imgdb.cn/item/611705185132923bf8d88506.jpg)

* Locked:表示mutex是否已经锁定。1：锁定。 0：没有锁定
* Waiter:表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量
* Starving:表示该mutex是否处于饥饿状态。0：没有饥饿。1：饥饿，表示有协程已经阻塞超过1ms
* Woken:表示是否有协程已被唤醒，0：没有协程唤醒。1：有协程唤醒，正在加锁过程中。
* 协程之间抢锁的过程实际上是给Locked赋值1的过程，能给Locked赋值为1，表示抢锁成功，抢不到锁就阻塞等待sema信号量来唤醒加锁。

### 3、mutex方法
Mutex对外提供两个方法
* Lock()：加锁方法
* Unlock()：解锁方法

## 二、加解锁过程
### 1、简单加锁
假定当前只有一个协程在加锁，没有其他协程干扰，加锁过程如下
![v2-39d4c316ff7a6467c3bb9761d6790197_1440w.jpe](https://pic.imgdb.cn/item/6117062a5132923bf8db929e.jpg)

加锁过程会去判断Locked是否为1，如果是0则把Locked置为1，表示加锁成功，其他状态位不会发生变化

### 2、加锁被阻塞
假定加锁时，锁被其他协程占用，那么加锁过程如下：
![v2-82f45531afff45d79db4856e73b5c343_1440w.jpe](https://pic.imgdb.cn/item/611707735132923bf8df23de.jpg)

如果协程对一个已经被占用的协程加锁时，Waiter计数器会增加1，此时B将会阻塞，直到Locked变为0后才会唤醒

### 3、简单解锁
假定解锁时，没有其他协程阻塞，那么解锁过程如下
![v2-1b7b5f7291ecce8cbcd9993eb1581910_1440w.jpeg](https://pic.imgdb.cn/item/611707db5132923bf8e04ca8.jpg)

由于此时watier值为0，表示没有其他协程在等待，所以无须释放信号量，只要把Locked置为0即可

### 4、解锁并释放协程
假定解锁过程，有1个或多个协程阻塞
![v2-e73adabf725d07af63b3c7d51fb42879_1440w.jpeg](https://pic.imgdb.cn/item/611708335132923bf8e15264.jpg)

协程A解锁分为两个步骤
* 将Locked置为0
* **释放sema信号量，唤醒协程B**，并将waiter减1

**此时Locked为0，协程B收到信号量，将Locked置为1，B获得锁**

## 三、自旋
### 1、自旋过程
加锁时，如果当前Locked位为1， 说明该锁被其他协程占用，但尝试加锁的协程并不会马上转为阻塞状态(<font color="red">不会进入阻塞队列</font>)，而是会持续的检测Locked位是否为0，这个过程称为**自旋**。

自旋的过程很短，如果在自旋过程中发现锁被释放，那么该协程会立即获得锁，**其他被唤醒的协程会继续阻塞**。

### 2、什么是自旋
自旋对应CPU指令"PAUSE"，CPU对该指令什么都不做，相当于CPU空转，对程序而要相当于sleep了一段时间，该时间非常短，go当前为30个时钟周期。

自旋次数要足够小，go为4，即自旋最多4次。

自旋过程会持续检测Locked是否为0，<font color="red">它不同于sleep，不需要协程转为睡眠状态</font>

### 3、自旋条件
* CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁。
* 协程调度机制中的Process数量要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋。
* 如果GOMAXPROCS>1，但是没有其他goroutine在运行，也不需要自旋转。
* 协程调度机制中当前P的本地队列必须为空。因为如果不为空，相较于自旋，切换到本地goroutine更有效率，为保障吞吐量也不会自旋，否则会**延迟协程调度**。 

### 4、自旋的优势
<font color="red">自旋的优势是更充分的利用了CPU，避免了协程切换。**因为当前申请加锁的协程获得了CPU(运行在CPU上的,很容易插队到被唤醒的routine前面)**，如果通过短时间自旋就可以获得锁，那么就可以接着直接运行，而不用阻塞并切换协程。</font>

### 5、自旋的问题
如果自旋过程中获得了锁，那么之前阻塞的协程就无法获得锁。如果等待加锁的协程特别多，而都在自旋过程中获得了锁，那么之前阻塞的协程就将一直阻塞(**导致不公平**)。

为了解决这个问题，在1.8的版本之后增加了一个状态Starving。在这个状态下不会自旋，**一定会有一个阻塞队列里的协程被唤醒并加锁。**

## 四、Mutex模式
现在我们看下Starving位的作用
### 1、Normal模式---自旋+排队
默认情况下都是Normal模式

当一个协程加锁失败时，不会立即转入等待状态，而是判断是否满足自旋条件，如果满足，则自旋(后面会说)来等待锁。但是要把自旋时间控制在较小范围内。

优点：更高的吞吐量，即更高的性能。

缺点：可能会出现队列尾端的goroutine迟迟抢不到锁(尾端延迟)的情况。

### 2、Starving模式(饥饿模式)---排队
* 释放锁时，如果waiter>0，即有阻塞等待的协程，会释放信号量来唤醒协程。
* 当阻塞协程被唤醒后，并不会立即获得锁，而是和处于自旋阶段的routine竞争，发现Locked=1，锁又被抢占，则又会阻塞，重新插入到阻塞队列头部。
* 但再次阻塞前会判断自上次阻塞到本次阻塞经历了多长时间，如果超过1ms的话，会将Mutex标记为"饥饿"模式，然后再阻塞。
* 这时候锁的所有权交给了头部的routine，后来者不会自旋，也不会尝试获取锁，而是直接**加到阻塞队列尾部**。
* 在饥饿模式下，如果有协程释放锁，那么一定会唤醒头部routine，并获得锁，同时会把waiter减1.

### 3、锁的状态转换
正常模式 <-> 饥饿模式
![aHR0cHM6Ly9tbWJpei52NDA.jpeg](https://pic.imgdb.cn/item/61172be45132923bf8621204.jpg)

## 五、 Woken状态
Woken状态作用于加锁和解锁的过程中。

在正常模式下，如果一个协程正在解锁，另一个协程在自旋等待加锁，在解锁时不用再唤醒其他goroutine了，已经有goroutine在这里等待了，以免唤醒更多的等待协程。即会把Woken状态置为1，通知解锁的协程不用释放信号量。

## 六、信号量 - runtime提供的等待队列
todo
* https://www.bilibili.com/video/BV1ZQ4y1f7go
自旋是给线程用的？？？ 

## 七、其他
### 1、补充说明
* 进入自旋时，还未进阻塞队列
* 阻塞队列是FIFO模式

### 2、为什么重复解锁要panic
unlock()过程分为将locked置为0，然后判断waiter是否大于0，如果大于0就释放信号量。

如果多次unlock()，则可能会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。



