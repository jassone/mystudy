## 抢占式和协作式

todo

线程由CPU调度是抢占式的，**协程由用户态调度是协作式的**，一个协程让出CPU后，才执行下一个协程。

## 一、v1.1 的非抢占式调用

在最初的 v1.1 版本中，只有当一个协程主动让出 CPU 资源（可以是运行结束，也可以是发生了系统调用或其他阻塞性操作），才能触发调度，进行下一个协程。

而如果一个协程运行了很久，也没有主动让出的动作发生，就会自私的一个人占用整个线程，该线程无法再去运行其他的 goroutine 了。

这种策略会让 Go 的并发性大打折扣。

## 二、v1.2 基于协作的抢占式调用

由于 v1.1 的非抢占式调用，以程序的并发效率影响实在太大。因为在下一个版本 v1.2 就紧急地对调度策略进行了临时的优化。经过优化后，go 从 v1.2 开始支持抢占式的调用：

1. 如果 sysmon 监控线程发现有个协程 A 执行之间太长了（或者 gc 场景，或者 stw 场景），那么会友好的在这个 A 协程的某个字段设置一个抢占标记 ；
2. 协程 A 在 call 一个函数的时候，会复用到扩容栈（morestack）的部分逻辑，检查到抢占标记之后，让出 cpu，切到调度主协程里；

之所以说 v1.2 的抢占式调用是临时的优化方案，是因为这种抢占式调度是基于协作的。在一些的边缘场景下，协程还是在会独自占用整个线程无法让出。比如在死循环中没有任何调用发生，那么这个协程将永远执行下去，永远不会发生调度，这显然是不可接受的。

从上面的流程中，你应该可以注意到，A 调度权被抢占有个前提：A 必须主动 call 函数，这样才能有走到 morestack 的机会。

## 三、 Go1.14 实现了基于信号的抢占式调度

以此来解决上述一些仍然无法被抢占解决的场景。

主要原理是 Go 程序在启动时，会在 `runtime.sighandler` 方法注册并且绑定 `SIGURG` 信号，绑定相应的 `runtime.doSigPreempt` 抢占方法。

同时在调度的 `runtime.sysmon` 方法会调用 `retake` 方法处理一下两种场景：

- 抢占阻塞在系统调用上的 P。
- 抢占运行时间过长的 G。

该方法会检测符合场景的 P，当满足上述两个场景之一时，就会发送信号给 M。M 收到信号后将会休眠正在阻塞的 Goroutine，调用绑定的信号方法，并进行重新调度。以此来解决这个问题。

注：在 Go 语言中，sysmon 会用于检测抢占。sysmon 是 Go 的 Runtime 的系统检测器，sysmon 可进行 forcegc、netpoll、retake 等一系列骚操作（via @xiaorui）。

在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这是协作式抢占调度。为什么说是真正的抢占式调用呢？

因为 v1.14 的这种抢占式调用是基于信号的，不管你的协程有没有意愿主动让出 cpu 运行权，只要你这个协程超过某个时间，就会发送信号强行夺取 cpu 运行权。



## 四、总结

尽管 Go 语言引入了这些抢占式调度特性，但它仍然主要是协作式调度。这是因为 Goroutine 在许多情况下主动让出计算资源（例如，当遇到 IO 阻塞时），这是协作式调度的核心特点。而抢占式调度特性只是在特定情况下作为补充，以确保在某些场景下调度的公平性和响应性。

因此，大家通常认为 Go 语言主要采用协作式调度，而抢占式调度仅在特定情况下作为辅助。这也是为什么大家说 Go 是协作式调度的原因。

### 1、**抢占式调度（公平性）**

- MP执行G是通过轮询的方式，**每个G只能执行10ms**，防止其他G饥饿。
- 抢占式调度只会在垃圾回收扫描任务时触发， 高版本是基于信号的抢占调度

![](https://pic.imgdb.cn/item/64b79af11ddac507cc77fad3.png)



https://my.oschina.net/u/4054187/blog/5499793

https://www.51cto.com/article/615156.html

* https://www.bilibili.com/video/BV1kL411p7mW?spm_id_from=333.999.0.0



https://blog.csdn.net/qq_44577070/article/details/129798695  经典

https://www.php.cn/faq/579585.html