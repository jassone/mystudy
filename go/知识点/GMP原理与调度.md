## GMP原理与调度
非常经典

https://www.yuque.com/aceld/golang/srxd6d

## 一、可增长的栈

OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。所以在Go语言中一次创建十万左右的goroutine也是可以的。

## 二、goroutine调度

**GPM是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。**区别于操作系统调度OS线程。

* G就是goroutine，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。

* P管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。

  P的个数是通过runtime.GOMAXPROCS设定（最大256），Go1.5版本之后默认为逻辑核心数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。同一时间，只能有GOMAXPROCS的Goroutine在同时运行，因为只有这么多个P。

  当一个新的G被创建的时候，会优先将G放入P的本地队列，满了才会放入全局队列。

* M（machine）是 golang 中对线程的抽象， Go 对操作系统线程（OS thread）的封装，可以看作操作系统内核线程。 **M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的。**

几点说明

- P开始执行G的时候，先从本地队列中获取G，如果没有，就去全局队列拿一些，如果没有，则去其他的P中偷取一些G来执行。
- M和P在执行的时候是1:1绑定的，真正的执行操作是由M内核线程来完成的，操作系统只能感知到M，然后将M放入CPU执行。当M因为G的一些系统调用阻塞的是时候，会释放P。然后runtime会创建新的线程、或者复用空闲的M来服务P。
- 如果一个M执行完了G任务，去寻找有没有空闲的P，如果没有就会进入休眠，等待被唤醒。



**P与M一般也是一一对应的。**他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。

单从线程调度讲，Go语言相比起其他语言的优势在于其他语言的OS线程是由OS内核来调度的，goroutine则是由Go运行时（runtime）自己的调度器调度的，这个**调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。** 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。

### 1、用到的技术
多线程复用（work stealing、hand off机制）

## 二、其他

- 认识Golang中的sysmon监控线程 https://blog.haohtml.com/archives/22745  todo