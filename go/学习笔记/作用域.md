## 作用域

## 一、什么是代码块

在 Go 语言中，**代码块一般就是由一个花括号包裹的表达式和语句的序列**，里面可以包含表达式和语句。

接下来，每个源码文件也都是一个代码块，每个函数也是一个代码块，每个`if`语句、`for`语句、`switch`语句和`select`语句都是一个代码块。甚至，`switch`或`select`语句中的`case`子句也都是独立的代码块。

走个极端，我就在`main`函数中写一对紧挨着的花括号算不算一个代码块？当然也算，这甚至还有个名词，叫“空代码块”。

隐式代码块，如：

- 所有 Go 代码形成一个最大的代码块，即：全域代码块
- 每个代码包中的代码共同组成了一个代码块，即：代码包代码块
- 每一个源码文件都是一个代码块，即：源码文件代码块
- 每一个 if、for、switch 和 select 语句都是一个代码块(**指整个if、for、switch 和 select 语句**)
- 每一个在 switch 或 select 语句中的 case 分支都是一个代码块

## 二、作用域

程序实体的访问权限有三种：包级私有的、模块级私有的和公开的。这其实就是 Go 语言在语言层面，依据代码块对程序实体作用域进行的定义。

包级私有和模块级私有访问权限对应的都是代码包代码块，公开的访问权限对应的是全域代码块。

总之，请记住，**一个程序实体的作用域总是会被限制在某个代码块中，而这个作用域最大的用处，就是对程序实体的访问权限的控制。**是对“高内聚，低耦合”这种程序设计思想的实践。

### 1、看个例子

```go
var block = "package"
func main() {
	block := "function"
	{
		block := "inner"
		fmt.Printf("The block is %s.\n", block) //The block is inner.
	}
	fmt.Printf("The block is %s.\n", block) //The block is function.
}
```

这个命令源码文件中有四个代码块，它们是：全域代码块、`main`包代表的代码块、`main`函数代表的代码块，以及在`main`函数中的一个用花括号包起来的代码块。

**这个查找过程(或者叫变量优先级)不只针对于变量，还适用于任何程序实体**。如下面所示。

- 首先，代码引用变量的时候总会最优先查找当前代码块中的那个变量。注意，这里的“当前代码块”仅仅是引用变量的代码所在的那个代码块，并不包含任何子代码块。
- 其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个代码块开始，一层一层地查找。
- 一般情况下，程序会一直查到当前代码包代表的代码块。如果仍然找不到，那么 Go 语言的编译器就会报错了。

### 2、包公开

这里注意一下：程序在找代表变量未加限定符的名字（即标识符）的时候，是不会去被导入的代码包中查找的。

如果要到被导入的包中查找，需要包公开。

### 2、变量遮蔽/屏蔽

上面例子中，虽然通过`var block = "package"`声明的变量作用域是整个`main`代码包，但是在`main`函数中，它却被那两个同名的变量“屏蔽”了。

再看下面这个例子

```go
func add(x, y int) (z int) {
    { // 不能在一个级别，引发 "z redeclared in this block" 错误。
        var z = x + y
        // return   // Error: z is shadowed during return， 因为上面的z不是函数签名返回的z
        return z // 必须显式返回。
    }
}
```

###  3、不同代码块中的重名变量与变量重声明中的变量区别

**为了方便描述，我就把不同代码块中的重名变量叫做“可重名变量”。**。

1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而**可重名变量之间不存在类似的限制，它们的类型可以是任意的(所以要特别注意变量“屏蔽” )**。
4. 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

![5556666.png](https://pic.imgdb.cn/item/63156f2f16f2c2beb1190f84.png)



## 三、可见性

* 声明在函数内部，是函数的本地值，类似private
* 声明在函数外部，是对当前包可见(包内所有.go文件都可见)的全局值，类似protect
* 声明在函数外部且首字母大写是所有包可见的全局值,类似public

## 四、最佳实践

### 1、将变量控制在最小作用域

```go
if num2 , err := strconv.ParseInt("333", 10, 16); err != nil {
   fmt.Println(err)
} else {
   fmt.Println(num2)
}

fmt.Println(num2) // 这里读取不到num2 , err

// 否则给num2赋值时，不用用:=
var num2 
if num2 , err = strconv.ParseInt("333", 10, 16); err != nil {
   fmt.Println(err)
} else {
   fmt.Println(num2)
}

fmt.Println(num2) // 这里可以读取到
```

## 相关wiki

https://zhuanlan.zhihu.com/p/351263185
https://blog.csdn.net/dianxin113/article/details/115009686



