## 变量常量
## 一、基础知识
### 1、定义变量和赋值变量

```go
var wg sync.WaitGroup // 1 定义类型，会有默认赋值
wg := sync.WaitGroup{} //赋值操作
```

### 2、声明

变量声明有三种。

* 声明变量的时候为其指定初始值
  `var 变量名 类型 = 表达式`

* 类型推导/类型推断
  类型省略，编译器会根据等号右边的值来推导变量的类型完成初始化。
  `var sex = 1`

* 短变量声明，仅函数体内使用。
  `n := 10`

![232323.png](https://pic.imgdb.cn/item/631555fc16f2c2beb1ff89e6.png)

##### 相关说明

* Go语言中的变量需要声明后才能使用。并且声明后必须使用(仅限函数内)。
* Go语言在声明变量的时候**，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值。**
* 匿名变量，用下划线表示。匿名变量**不占用命名空间**，**不会分配内存**，所以匿名变量之间**不存在重复声明**。
    `x, _ := foo()`
* 类型推断是一种编程语言在编译期自动解释表达式类型的能力(表达式类型就是对表达式进行求值后得到结果的类型)。**好处**： Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外负担   （实际上，它恰恰可以避免散弹式的代码修改），更不会损失程序的运行效率。
* 短变量声明，实际上就是 Go 语言的类型推断再加上一点点语法糖。

### 3、变量的重声明

```go
var err error
n, err := io.WriteString(os.Stdout, "Hello, everyone!\n") // 对err进行了重声明
```

通过短变量声明，我们可以对**同一个代码块中的变量进行重声明**。其含义是**对已经声明过的变量再次声明**。变量重声明的前提条件如下。

1. 由于变量的类型在其初始化时就已经确定了，所以对它**再次声明时赋予的类型必须与其原本的类型相同**，否则会产生编译错误。
2. 变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了，即两个变量了。
3. **同一级作用域内不支持重复声明（非短声明，为var声明）**。
4. **变量的重声明只有在使用短变量声明时才会发生**，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字`var`的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了。
5. 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明。

变量重声明其实算是一个语法糖（或者叫便利措施）。它允许我们在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量。

### 4、默认值

每个变量会被初始化成其类型的默认值。
* 整型和浮点型变量的默认值为0。 
* 字符串变量的默认值为空字符串。 
* 布尔型变量默认为false。 
* 切片、函数、指针变量的默认为nil。

### 5、Named Type和Unnamed Type

Named Type 有两类：

* 内置类型，比如 int, int64, float, string, bool 等；
* 使用关键字 type 声明的类型；

Unnamed Type 是基于已有的 Named Type 组合一起的类型
例如：struct{}、[]string、interface{}、map[string]bool 等。

### 6、其他

* 常量间的所有算术运算、逻辑运算和比较运算的结果也是常量。对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex 和 unsafe.Sizeof。todo ???

### 7、变量声明示例

```go
	// 声明字符
	var ch1 byte = 65
	var ch12 byte = 'A'
  //var c2 byte = '中' //运行时会报错：溢出。 特别注意。

	// 声明字符串
	var str string = "aaa"

	// 声明整型
	var num int = 12
```

## 二、引用变量

详见“引用变量”章节。