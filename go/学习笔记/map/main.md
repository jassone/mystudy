## map
map是一种**无序**的基于key-value的数据结构，**map是引用类型，必须初始化才能使用。**

## 一、基础知识
### 1、语法
map的定义语法如下
```go
map[KeyType]ValueType
```
* KeyType:表示键的类型。

* ValueType:表示键对应的值的类型。

**map类型的变量默认初始值为nil，需要使用make()函数来分配内存**。
语法为：
```go
make(map[KeyType]ValueType, [cap])
```
其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。

### 2、基本使用
map中的数据都是成对出现的。
```go
scoreMap := make(map[string]int, 8)
scoreMap["张三"] = 90
```

### 3、判断某个键是否存在

```go
value, ok := map[key]
if ok {
    // 存在
} else {
    // value返回零值。
}
```
这种方式叫做：ok-idiom（A跌目）模式：多返回值中用一个名为ok的布尔值来标记操作是否成功。

### 4、map的遍历
使用range。遍历map时的元素顺序与添加键值对的顺序无关。

### 5、使用delete()函数删除键值对
```go
delete(map, key)
```

### 6、特性
* 字典并不是并发安全
* map是hash，无序的
* **map不能用new()来构建，因为会分配一个引用对象，获得一个空引用指针，相当于声明了一个未初始化的变量并取他的地址**。
* **获取一个不存在的key值，不会报错，会返回零值。**
* map越界了会自动扩容。

## 二、map值

### 1、map 中的元素是不可寻址的
比如 map 一个字段的值是 struct 类型，则无法直接更新该 struct 的单个字段。
```go
type data struct {
    name string
}

func main() {
    m := map[string]data{
        "x": {"Tom"},
    }
    m["x"].name = "Jerry" //panic: runtime error: invalid memory address or nil pointer dereference
}

// slice可以
func main2() {
    s := []data{{"Tom"}}
    s[0].name = "Jerry"
    fmt.Println(s)    // [{Jerry}]
}
```

### 2、更新 map 中 struct 元素的字段值，有 2 个方法

##### a) 使用局部变量
提取整个 struct 到局部变量中，修改字段值后再整个赋值

```go
type data struct {
    name string
}
func main() {
    m := map[string]data{
        "x": {"Tom"},
    }
    r := m["x"]
    r.name = "Jerry"
    m["x"] = r
    fmt.Println(m)
}
```
##### b) 使用指向元素的 map 指针

```go
func main() {
    m := map[string]*data{
        "x": {"Tom"},
    }

    m["x"].name = "Jerry"    // 直接修改 m["x"] 中的字段
    fmt.Println(m["x"])
}
```

## 三、相关问题

### 1、字典的键类型不能是哪些类型

**键值判断需要进过建值的哈希值判等，键值判等两步骤。**

Go 语言字典的键类型不可以是函数类型、字典类型和切片类型。

Go 语言规范规定，在键类型的值之间必须可以施加操作符`==`和`!=`。换句话说，**键类型的值必须要支持判等操作**。**由于函数类型、字典类型和切片类型的值并不支持判等操作，所以字典的键类型不能是这些类型**。

另外，如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic。

还要注意，如果键的类型是数组类型，那么还要确保该类型里面的元素类型不是函数类型、字典类型或切片类型。比如，由于类型`[1][]string`的元素类型是`[]string`，所以它就不能作为字典类型的键类型。

如果键的哈希值有相等的，那就再用键值本身去对比一次。为什么还要对比？原因是，不同值的哈希值是可能相同的。这有个术语，叫做“哈希碰撞”。

所以，即使哈希值一样，键值也不一定一样。如果键类型的值之间无法判断相等，那么此时这个映射的过程就没办法处理了。

### 2、应该优先考虑哪些类型作为字典的键类型

**求哈希和判等操作的速度越快，对应的类型就越适合作为键类型。**

对于所有的基本类型、指针类型，以及数组类型、结构体类型和接口类型，Go 语言都有一套算法与之对应。这套算法中就包含了哈希和判等。以求哈希的操作为例，宽度越小的类型速度通常越快。对于**布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈希越快。**

再来看高级类型。**对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并**，所以速度就取决于它的元素类型以及它的长度。细则同上。

与之类似，**对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并**，所以关键在于它的各个字段的类型以及字段的数量。而对于**接口类型，具体的哈希算法则由值的实际类型决定**。

不建议你使用这些高级数据类型作为字典的键类型，不仅仅是因为对它们的值求哈希，以及判等的速度较慢，更是因为在它们的值中存在变数。还有**如果Go 运行时系统发现某个键值不支持判等操作，那么就会立即抛出一个 panic。**

那么，在那些基本类型中应该优先选择哪一个？答案是，优先**选用数值类型和指针类型**，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。

### 3、在值为`nil`的字典上执行操作会报错吗

当试图在一个值为`nil`的字典中添加键 - 元素对的时候，Go 语言的运行时系统就会立即抛出一个 panic。而其他任何操作都不会引起错误。

## 四、相关wiki

- map基础 https://www.topgoer.com/go%E5%9F%BA%E7%A1%80/Map.html

