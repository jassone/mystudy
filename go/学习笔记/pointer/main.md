## pointer

### 1、先看下什么是值类型
定义：**变量直接指向存在内存中的值，这个变量称之为值类型**。

* 值类型的变量的值存储在栈中。
* 将一个值类型变量赋值给另一个变量被称为值拷贝。

### 2、指针是啥

定义：**一个变量指向内存中值所在的内存地址，我们称这个变量为指针类型**。

**Go语言中的指针不能进行偏移和运算，是安全指针**。即不能对指针做操作，只能默认修改指针地址的值。

Go语言中的**函数传参都是值拷贝(看上去的传引，其实只是把地址当做参数传递过去而已)**，当我们想要修改某个变量的时候，我们可以创建一个指向该变量地址的指针变量。传递数据使用指针，而无须拷贝数据。。Go语言中的指针操作只需要记住两个符号：
* & ：取地址符号
* \* ：指针运算符。可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是用来取值。

```
// 声明一个整型变量
num := 42

// 声明一个指向整型变量的指针
ptr := &num

// 打印指针变量存储的值
fmt.Println(*ptr)

// 打印指针变量的地址
fmt.Println(&ptr) 
fmt.Printf("指针变量的地址: %p\n", &ptr)

// 打印指针变量存储的指针值
fmt.Printf("指针变量存储的指针值: %p\n", ptr)

/********非指针变量*******/
// 声明一个整型变量
num := 42

// 声明一个指向整型变量的指针
ptr := num

// 打印变量的地址
fmt.Println(&ptr)               // 0x14000122008
fmt.Printf("变量的地址: %p\n", &ptr) // 0x14000122008

// 打印变量存储的指针值
fmt.Printf("变量存储的指针值: %p\n", ptr) // %!p(int=42)
```



### 3、值传递和引用传递

* 一般来说，地址拷贝更为高效。而值拷贝取决于拷贝的对象大小，对象越大，则性能越低。

* **map、slice、chan、指针、interface默认以引用的方式传递。**

C语言系列的语言，函数的参数总是按值传递，也就是说函数总能得到参数的副本，就像有一个赋值语句将值分配给参数一样。

有两个比较特殊的数据结构就是 Map 和 Slice。它们的行为和指针很像，**它们包含一个指向基础数据的一个指针**，**所以 Map 和 Slice 作为参数的时候，不会复制他们所指向的数据，而且在函数中可以直接改变数据。**

如果函数的参数是一个interface ,**interface 值包含 struct 将会复制整个 struct，如果包含的是指针，那也不会拷贝指针指向的数据。**

## 一、基础知识
### 1、指针地址和指针类型

Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：\*int、\*int64、\*string等。

```go
取变量指针的语法如下：
ptr := &v    // v的类型为T

其中：
v:代表被取地址的变量，类型为T
ptr:用于接收地址的变量，

ptr的类型就为*T，称做T的指针类型。*代表指针。
```

![34543234.png](https://pic.imgdb.cn/item/6231d0f95baa1a80ab226338.png)

### 2、指针取值
对指针使用*操作，也就是指针取值。

```go
 //指针取值
a := 10
b := &a // 取变量a的地址，将指针保存到b中
c := *b // 指针取值（根据指针去内存取值）
```

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：
* 对变量进行取地址（&）操作，可以获得这个变量的指针变量。
* 指针变量的值是指针地址。
* 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。

### 3、空指针
**当一个指针被定义后没有分配到任何变量时，它的值为 nil**。

空指针的判断
```go
var p *string
fmt.Println(p)
fmt.Printf("p的值是%v\n", p)
if p != nil {
    fmt.Println("非空")
} else {
    fmt.Println("空值")
}
// 输出
<nil>
p的值是<nil>
空值
```

### 4、引用类型变量和值类型变量

```go
var a *int
*a = 100 // panic
fmt.Println(*a) 

var b map[string]int
b["测试"] = 100 // panic
fmt.Println(b) 
```

执行上面的代码会引发panic。

* **对于引用类型的变量，使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。**

* **对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。**

### 5、变量比较

**引用类型只能和nil比较(比如切片，map)，值类型可以比较(因为内存总是被初始化过的，比如数组)**。

## 二、new和make

Go语言中new和make是内建的两个函数，主要用来分配内存。

### 1、new

**new是一个内置的函数。**
* 用于给类型分配内存的。
* 是堆空间分配。

**new(T) 会为 T 类型的新值分配已置零值的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。**

比如可以对**struct,int,string等**进行初始化。

```go
函数签名如下：
func new(Type) *Type

a := new(int)
b := new(bool)
type People struct {
	Name string
}
c :=new(People)
c.Name = "a"

fmt.Printf("%T\n", a) // *int
fmt.Printf("%T\n", b) // *bool
fmt.Println(*a)       // 0
fmt.Println(*b)       // false
fmt.Println(*c)       // {a}
```

* Type表示类型，new函数只接受一个参数，这个**参数是一个类型**
* \*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。

示例代码中var a *int只是声明了一个指针变量a但是没有初始化。
改下代码：
```go
var a *int
a = new(int)
*a = 10
fmt.Println(*a)
```

##### a）操作slice
```go
ps := new([]string)
(*ps)[0] = "a" //panic: runtime error: index out of range [0] with length 0
// 上面程序可以通过编译
```
对于slice，new同样会分配slice结构空间内存，即data,len,cap。但**new不负责底层数组的分配**，结果就是data=nil,len=cap=0，返回值是slice结构的起始地址。

即ps就是个地址，此时这slice还没有底层数组。

![KwYiP5O53ooYECQUpFBwC5AA_706_498.png](https://pic.imgdb.cn/item/623d218827f86abb2a08aa5e.png)

可以通过append来添加底层数组
```go
ps = append(ps, "a") // 这里是错误的
*ps = append(*ps, "a")
```
### 2、make
**make也是内置函数。**我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。

* 用于给类型分配内存的。
* 是堆空间分配。

**它只用于slice、map以及chan的内存创建。make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的 T 的引用。 即它返回的类型就是这三个类型本身，而不是他们的指针类型。**因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

make函数的函数签名如下：
```go
func make(t Type, size ...IntegerType) Type
```

示例中var b map[string]int只是声明变量b是一个map类型的变量，需要使用make函数进行初始化操作之后，才能对其进行键值对赋值：
```go
var b map[string]int
b = make(map[string]int, 10)
b["测试"] = 100
fmt.Println(b)
```

## 三、传值和传引场景区别
### 1、函数
是修改源数据还是修改副本依据传参定义是否是指针。
* 形参为值类型时，只能传值。形参为接口除外。
* 形参为指针类型时，只能传指针。形参为接口除外。

### 2、接口
**接收者可以拿到本身的所有数据**。

是修改源数据还是修改副本依据接收者定义是否是指针。

* 接收者为值类型时，传值传引都可以
* 接收者为指针类型时，只能传指针

### 3、方法
**接收者可以拿到本身的所有数据**。

是修改源数据还是修改副本依据接收者定义是否是指针。
* 接收者为值类型时，传值传引都可以
* 接收者为指针类型时，传值传引都可以

```go
// 下面的语法糖转换(在编译期间做的)
func (pa A) get(){}
func (a *A) set(){}
a := A{}
pa := &a

pa.get() -> (*pa).get() 
a.set() ->  (&a).set()
```

## 四、几个名词

* 变量是抽象出来的概念，go语言程序运行时即表示内存值
* 内存地址即 内存值所在的内存空间的编号
* 指针变量：是一种占位符，用于引用计算机的内存地址。可理解为内存地址的标签

## 五、相关问题

### 1、隐似转换

这里声明的时候同时赋值

```
itemList := []*userSrv.Item{
   {Id: cast.ToInt32(exchange["item_id"]), Num: cast.ToInt64(exchange["item_num"])},
}
```



## 六、如何选择

在Go语言中，函数参数传递采用的是值传递（pass by value）的方式。这意味着函数接收的是实际参数的副本，而不是原始数据本身。这引发了一些关于传值和传引用的讨论。

传值的优点包括：

简单性： 值传递是一种简单而直观的方式。函数接收参数的副本，不会影响原始数据，避免了副作用。

安全性： 由于函数无法修改原始数据，可以更容易理解和维护代码。

性能： 值传递通常比引用传递更高效，因为不涉及对原始数据的复杂引用和解引用操作。

然而，有时候传值可能会导致一些不便之处，特别是在处理大型数据结构时。如果数据量很大，传递副本可能会带来性能开销和内存消耗。在这种情况下，可以考虑传递指针或使用切片、映射等引用类型，以便在函数中修改原始数据。

总体而言，在Go中，传值是首选的方式，但在需要修改原始数据或处理大型数据结构时，可以考虑传递指针或引用类型。要注意避免副作用和不必要的复杂性，以确保代码的可读性和可维护性。

## 注意点

```
func aaa(num *string) {
	num2 := "2323"
	num = &num2  // // 只是让局部变量ptr指向了新的地址
	fmt.Println(*num)
}

func main() {
	index := "0-0"
	aaa(&index)
}
这个例子不会修改index的值


正确的是
func aaa(num *string) {
	*num =  "2323"  // 解引用并修改指针指向的内存
	fmt.Println(*num) 
}

```

