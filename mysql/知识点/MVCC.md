## MVCC
几点说明
* mysql默认隔离级别是可重复读，5.1以后默认存储引擎是InnoDB。

* 以下都是围绕InnoDB引擎来讲，因为myIsam不支持事务。

## 一、先梳理一些概念名词
### 1 脏读/不可重复读/幻读

`脏读`是指读取到其他事务正在处理的未提交的数据。
![8E8CB6B3-79DE-4FA8-8EBE-79BC7C00F728.png](https://pic.imgdb.cn/item/618ce4c42ab3f51d916e303f.png)

`不可重复读`是指A事务在执行过程中，B事务对数据进行了修改或删除，导致A两次读取的数据不一致。重点在于update和delete(锁行即可)。
![208DBAA6-711B-498C-8BE2-393512B958A3.png](https://pic.imgdb.cn/item/618ce5082ab3f51d916e4a02.png)

`幻读`是指A事务在执行过程中，B事务新增了符合A事务要查询的数据，导致A两次读取的数据不一致。重点在于insert(锁表即可)。
![D3212254-911B-48D3-A7D1-6148B8099D8B.png](https://pic.imgdb.cn/item/618ce5722ab3f51d916e7470.png)

### 2 隔离级别
![327747C6-E821-45E4-931F-F680A71D9FA2.png](https://pic.imgdb.cn/item/618ce5b22ab3f51d916e8b10.png)

* 读已提交简称：RC
* 可重复读简称：RR

在MySQL InnoDB存储引擎下RC、RR基于MVCC（多版本并发控制）进行并发事务控制。

### 3 当前读/快照读
##### 当前读
它读取的数据库记录，都是当前`最新的版本`，会对当前读取的数据进行`加锁`，防止其他事务修改数据。使用了悲观锁，即`通过锁控制的`。

如下操作都是当前读：

```sql
select ... lock in share mode (共享锁)

select ... for update (排他锁)

update (排他锁)

insert (排他锁)

delete (排他锁)

串行化事务隔离级别
```

##### 快照读
快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。`为了实现不用加锁实现可重复读`。

如下操作是快照读：

```sql
不加锁的select操作（注：事务级别不是串行化）
```

## 二、什么是MVCC
全称Multi-Version Concurrency Control，即多版本并发控制，是一种`可见性算法`。基于`数据版本`对并发事务进行访问，主要是为了`提高数据库的并发性能`。

同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。

这个读是指的`快照读`，而不是当前读。使读写操作没有冲突”的一个`抽象概念`。这个概念需要具体功能去实现，这个具体实现就是`快照读`。
 
## 三、MVCC解决并发哪些问题
### 1 先看下数据库并发场景
* 读-读：不存在任何问题，也不需要并发控制

* 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

* 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失。?TODO

### 2 mvcc的作用
mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。

读操作只读取该事务开始前的数据库快照。

解决问题如下：
* 并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。

* 解决脏读、幻读、不可重复读等事务隔离问题，但不能解决上面的写-写 更新丢失问题。

因此有了下面提高并发性能的组合拳：
* MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突
* MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突

## 四、MVCC的实现原理
它的实现原理主要是版本链，undo日志 ，Read View来实现的。

### 1 版本链(undolog+事务自增id+回滚指针)
我们数据库中的每行数据，还有几个隐藏字段。

![2DE134C6-10F8-4CA9-9D3F-129291C9D6BA.png](https://pic.imgdb.cn/item/618b929e2ab3f51d91f558a8.png)

* db_trx_id
6byte，创建这条记录/最后一次修改该记录的`已提交`的事务ID。是自增id。

* db_roll_pointer（版本链关键）
7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里），用于配合undo日志，指向上一个旧版本。

* db_row_id
6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。

* 实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了

每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样：

![8F03DB99-1732-42F9-8F8D-DB806582861E.png](https://pic.imgdb.cn/item/618b99202ab3f51d91f966fb.png)

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含`生成该版本时对应的事务id`，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。

## 五、Read View(读视图)
事务进行`快照读`操作的时候生成的读视图(Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照。

记录并维护系统当前`活跃事务的ID`(`没有commit`，当每个事务开启时，都会被分配一个ID, 这个`ID是递增的`，`所以越新的事务，ID值越大`)，是系统中当前不应该被本事务看到的其他事务id列表。

`用在RC,RR隔离级别里`。

### 1 用途
Read View主要是用来做`可见性判断`的, 即当我们某个事务执行快照读的时候，会创建一个Read View读视图，用它的比作条件用来`判断当前事务能够看到哪个版本的数据`，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

### 2 Read View几个属性
* m_ids: 当前系统活跃(`未提交`)事务版本号集合。

* min_trx_id: 创建当前read view 时“系统正处于活跃事务最小版本号”，也就是m_ids中的最小值。

* max_trx_id: 创建当前read view 时“当前系统最大事务版本号+1”。

* creator_trx_id: 创建当前read view的事务版本号；

## 六 MVCC和事务隔离级别

### 1 RR、RC生成时机
* RC隔离级别下，是每个快照读都会生成并获取`最新`的Read View；

* 在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View，之后的查询就不会重复生成了，所以一个事务的查询结果每次都是一样的。(有例外，后面会提到)

### 2 RC模式下MVCC的算法实现
![23232432423.png](https://pic.imgdb.cn/item/618de4672ab3f51d91c57cfd.png)

如果这时候有其他事务修改了数据但未提交，则不会读取到，如下:
![2343245435456.png](https://pic.imgdb.cn/item/618de57f2ab3f51d91c6004e.png)

如果这时候有其他事务提交了，则会读取到，如下:
![657878987.png](https://pic.imgdb.cn/item/618de5a32ab3f51d91c610c6.png)

每次快照读，都会重新生成一份新的(readview 4个参数可能改变).

> 当前模式会出现不可重复读和幻读问题。

### 3 RR模式下MVCC的算法实现
![11212323.png](https://pic.imgdb.cn/item/618df4822ab3f51d91cbdfe3.png)
这时候版本链都没有发送变化(readview 4个参数会一直不变)，所以读取到的数据都一样。

在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。

##### RR级别下使用MVCC能避免幻读吗？能，但不完全能！

当两次快照读之间存在当前读，ReadView会重新生成，导致产生幻读。
![324254656.png](https://pic.imgdb.cn/item/618e18ac2ab3f51d91d946a0.png)

## 七、知识点串联
在InnoDB存储引擎下，隔离级别为RC/RR隔离级别情况下，为了解决幻读/不可重复读，提出了MVCC这样一个`抽象概念`，即在快照读的时候，使用来Read view来实现。

## 八、相关问题
### 1 UNDO_LOG不是会被删除吗？中间数据万一被删了版本链不就断了？UNDO_LOG版本链不是立即删除，MySQL确保版本链数据不再被“引用”后再进行删除。







