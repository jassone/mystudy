## MVCC
几点说明
* mysql默认隔离级别是可重复读，5.1以后默认存储引擎是InnoDB。
* 以下都是围绕InnoDB引擎来讲，因为myIsam不支持事务。
* **只针对聚簇索引(因为只有聚簇索引才有trx_id和roll_pointer隐藏列)**。

## 一、先梳理一些概念名词
### 1 脏读/不可重复读/幻读

**脏读**是指读取到其他事务正在处理的未提交的数据。
![8E8CB6B3-79DE-4FA8-8EBE-79BC7C00F728.png](https://pic.imgdb.cn/item/618ce4c42ab3f51d916e303f.png)

**不可重复读**是指A事务在执行过程中，B事务对数据进行了修改或删除，导致A两次读取的数据不一致。重点在于update和delete(锁行即可)。
![208DBAA6-711B-498C-8BE2-393512B958A3.png](https://pic.imgdb.cn/item/618ce5082ab3f51d916e4a02.png)

**幻读**是指A事务在执行过程中，B事务新增了符合A事务要查询的数据，导致A两次读取的数据不一致。重点在于insert(锁表即可)。
![D3212254-911B-48D3-A7D1-6148B8099D8B.png](https://pic.imgdb.cn/item/618ce5722ab3f51d916e7470.png)

### 2 隔离级别
![327747C6-E821-45E4-931F-F680A71D9FA2.png](https://pic.imgdb.cn/item/618ce5b22ab3f51d916e8b10.png)

* 读已提交简称：RC
* 可重复读简称：RR
* **RC和RR都必须保证读到已经提交的事务的记录**。

在MySQL InnoDB存储引擎下RC、RR基于MVCC（多版本并发控制）进行并发事务控制。

### 3 当前读

它读取的数据库记录，都是当前**最新的版本**，会对当前读取的数据进行**加锁**，防止其他事务修改数据。使用了悲观锁，即**通过锁控制的**。

如下操作都是当前读：

```sql
select ... lock in share mode (共享锁)

select ... for update (排他锁)

update (排他锁)

insert (排他锁)

delete (排他锁)

串行化事务隔离级别
```

### 4、快照读

快照读的实现是基于多版本并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前历史版本的数据。**为了实现不用加锁实现可重复读**。

如下操作是快照读：

```sql
不加锁的select操作（注：事务级别不是串行化）
```

## 二、什么是MVCC
全称Multi-Version Concurrency Control，即多版本并发控制，是一种**可见性算法**。基于**数据版本**对并发事务进行访问，主要是为了**提高数据库的并发性能**。
这样可以让并发执行的事务的执行结果和串行执行的结果一样。

同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生**读—写请求冲突**时不用加锁。

这个读是指的**快照读**，而不是当前读。使读写操作没有冲突的一个**抽象概念**。这个概念需要具体功能去实现，这个具体实现就是**快照读**。

## 三、MVCC解决并发哪些问题

### 1 先看下数据库并发场景
* 读-读：不存在任何问题，也不需要并发控制

* 读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读

* 写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失。?TODO

### 2 mvcc的作用
mvcc用来解决读—写冲突的无锁并发控制，就是为事务分配单向增长的时间戳。为每个数据修改保存一个版本，版本与事务时间戳相关联。

解决问题如下：
* 并发读-写时：可以做到读操作不阻塞写操作，同时写操作也不会阻塞读操作。

* 解决脏读、幻读、不可重复读等事务隔离问题，**但不能解决上面的写-写 更新丢失问题**。

因此有了下面提高并发性能的组合拳：
* **MVCC + 悲观锁**：MVCC解决读写冲突，悲观锁解决写写冲突
* **MVCC + 乐观锁**：MVCC解决读写冲突，乐观锁解决写写冲突

## 四、MVCC的实现原理
它的实现原理主要是**版本链，undo log ，Read View**来实现的。

### 1 版本链(undo log+事务自增id+回滚指针)

我们数据库中的每行数据，还有几个隐藏字段。

![2DE134C6-10F8-4CA9-9D3F-129291C9D6BA.png](https://pic.imgdb.cn/item/618b929e2ab3f51d91f558a8.png)

* db_trx_id(必须)
6byte，创建这条记录/最后一次修改该记录的**已提交**的事务ID。是自增id。

* db_roll_pointer（必须，版本链关键）
7byte，回滚指针，指向这条**记录的上一个版本**（存储于rollback segment里），

* db_row_id（非必须）
6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以db_row_id产生一个聚簇索引。

  InnoDB 表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键。

* 实际还有一个删除flag隐藏字段, 记录被更新或删除并不代表真的删除，而是删除flag变了。

每次对数据库记录进行改动，都会记录一条undo日志，每条undo日志也都有一个roll_pointer属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表。所以现在的情况就像下图一样：

![8F03DB99-1732-42F9-8F8D-DB806582861E.png](https://pic.imgdb.cn/item/618b99202ab3f51d91f966fb.png)

![20220125101957.jpg](https://pic.imgdb.cn/item/61ef5e572ab3f51d911102b1.jpg)

对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一个链表，我们把这个链表称之为**版本链**，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成**该版本时对应的事务id**，这个信息很重要，在根据ReadView判断版本可见性的时候会用到。

**undo log中只会记录一些索引列以及被更新的列的信息**。其他列则会依次顺着版本链找，一直找到合适的版本中有更改列值为止(如果某列从来没有更新过，则一直找到版本链头部)。

## 五、Read View(读视图)

事务进行**快照读**操作的时候生成的读视图(Read View)，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照。

记录并维护系统当前活跃事务的ID(没有commit，这个**ID是递增的**，所以越新的事务，ID值越大)，是系统中当前不应该被本事务看到的其他事务id列表。

注意：**只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0**。

**用在RC,RR隔离级别里。**

### 1 用途

Read View主要是用来做**可见性判断**的, 即当我们某个事务执行快照读的时候，会创建一个Read View读视图，用它的比作条件用来**判断当前事务能够看到哪个版本的数据**，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。

### 2 Read View几个属性

* m_ids: 在生成 ReadView 时当前系统中活跃的(**未提交**)读写事务的 事务id 列表集合。

* min_trx_id: 在生成 ReadView 时当前“系统正处于活跃的读写事务最小版本号”，也就是m_ids中的最小值。

* max_trx_id: 在生成 ReadView 时“当前系统最大事务版本号+1”(应该分配给下一个事务的 id 值。)。

* creator_trx_id: 创建当前read view的事务版本号。
  
### 3 判断流程

* 如果被访问版本的 trx_id 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。
* 如果被访问版本的 trx_id 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，**那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性**，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

## 六 MVCC和事务隔离级别

### 1 RR、RC生成时机
* RC隔离级别下，每次查询开始时都会生成一个独立的ReadView。

* 在RR隔离级别下，只会在第一次执行查询语句时生成一个 ReadView ，之后的查询就不会重复生成了，而是直接复用之前的ReadView。所以一个事务的查询结果每次都是一样的。(有例外，后面会提到)

### 2 RC模式下MVCC的算法实现
![23232432423.png](https://pic.imgdb.cn/item/618de4672ab3f51d91c57cfd.png)

如果这时候有其他事务修改了数据但未提交，则不会读取到，如下:
![2343245435456.png](https://pic.imgdb.cn/item/618de57f2ab3f51d91c6004e.png)

如果这时候有其他事务提交了，则会读取到，如下:
![657878987.png](https://pic.imgdb.cn/item/618de5a32ab3f51d91c610c6.png)

每次快照读，都会重新生成一份新的(readview 4个参数可能改变).

> 当前模式会出现不可重复读和幻读问题。

### 3 RR模式下MVCC的算法实现
![11212323.png](https://pic.imgdb.cn/item/618df4822ab3f51d91cbdfe3.png)
这时候版本链都没有发送变化(readview 4个参数会一直不变)，所以读取到的数据都一样。

在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见。

##### RR级别下使用MVCC能避免幻读吗？
能，但不完全能！

当两次快照读之间存在当前读，ReadView会重新生成，导致产生幻读(其实这时候update就是当前事务中的sql，所以是当前读)。
![324254656.png](https://pic.imgdb.cn/item/618e18ac2ab3f51d91d946a0.png)

## 七、二级索引与MVCC
如果某个查询语句是使用二级索引来执行查询呢，如何来判断可见性呢？

比如

```sql
begin;
select name from tb where name ='jack';
```
判断可见性步骤
### 步骤1
二级索引页面的Page Header部分有一个名为PAGE_MAX_TRX_ID的属性，每当对该页面中的记录执行增删改操作时，如果执行该操作的事务的事务id大于PAGE_MAX_TRX_ID值，就会把PAGE_MAX_TRX_ID值设置为执行该操作该操作的事务的事务id。这也就意味着PAGE_MAX_TRX_ID值代表着修改该二级索引页面的最大事务id是什么。

当select语句访问某个二级索引记录时，首先会看一下对应的ReadView的min_trx_id是否大于该页面的PAGE_MAX_TRX_ID值，如果是，说明该页面中的所有记录都对该ReadView可见；否则就执行下一步骤，回表后再判断可见性。

### 步骤2
利用二级索引记录中的主键值进行回表操作，得到对应的聚簇索引记录后再按照前面讲过的方式找到对该ReadView可见的第一个版本，然后判断该版本中相应的二级索引列的值是否与利用该二级索引查询时的值相同。本例子就是判断找到的第一个可见版本的name是不是'jack'。如果是，则就把这条记录发送给客户端，否则就跳过该记录。

## 八、purge
有下面两种情况
* insert undo 在事务提交之后就可以被释放掉了(实际上insert undo只在事务回滚时才用得上)，而 update undo 由于还需要支持 MVCC ，不能立即删除掉。
* 为了支持 MVCC ，对于 delete mark 操作来说（delete操作时打标的），仅仅是在记录上打一个删除标记，并没有真正将它删除掉。

随着系统的运行，在确定系统中包含最早产生的那个 ReadView 的事务不会再访问某些 update undo日志 以及被打了删除标记的记录后，有一个后台运行的 `purge线程` 会把它们真正的删除掉。

## 九、知识点串联
在InnoDB存储引擎下，隔离级别为RC/RR隔离级别情况下，为了解决幻读/不可重复读，提出了MVCC这样一个`抽象概念`，即在快照读的时候，使用来Read view来实现。

## 十、相关问题









