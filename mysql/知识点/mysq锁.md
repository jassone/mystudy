## mysql的锁
## 一、简介
不少人在开发的时候，应该很少会注意到这些锁的问题，也很少会给程序加锁(除了库存这些对数量准确性要求极高的情况下)，即使我们不会这些锁知识，我们的程序在一般情况下还是可以跑得好好的。

**因为数据库隐式帮我们加了这些锁了，只有在某些特定的场景下我们才需要手动加锁。**

**锁机制是存储引擎层面的**，服务器层完全不了解存储引擎中的锁实现。

### 1、MySQL锁可以按使用方式分为：
* 乐观锁
* 悲观锁

### 2、按粒度分可以分为：
* 表级锁
* 行级锁
* 页级锁

## 二、表锁
**表锁: 开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。**

表锁下又分为两种模式： 
* 表读锁（Table Read Lock）
* 表写锁（Table Write Lock）

![2090222-20200831212412534-452943339.jpeg](https://pic.imgdb.cn/item/6209c9092ab3f51d9157e753.jpg)
从上图可以清晰看到，在表读锁和表写锁的环境下：
* 读读不阻塞： 当前用户在读数据，其他的用户也在读数据，不会加锁

* 读写阻塞： 当前用户在读数据，其他的用户不能修改当前用户读的数据，会加锁！

* 写写阻塞： 当前用户在修改数据，其他的用户不能修改当前用户正在修改的数据，会加锁！

从上面已经看到了：读锁和写锁是互斥的，读写操作是串行。
* 如果某个进程想要获取读锁，同时另外一个进程想要获取写锁。在mysql中，写锁是优先于读锁的！

* 写锁和读锁优先级的问题是可以通过参数调节的：max_write_lock_count和low-priority-updates

注意：？？？？？
MyISAM支持查询与插入操作的并发进行，也可以通过系统变量concurrent_insert指定哪种模式。在MyISAM中默认：如果MyISAM表的中间没有被删除的行的话，那MyISAM是允许在一个进程读表的同时，另一个进程从表尾做插入记录的。但是INNODB是不支持的。

## 三、行锁
**行锁: 开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高 不同的存储引擎支持的锁粒度是不一样的。**

InnoDB实现了以下两种类型的行锁：
* 共享锁（S锁、读锁）： 允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。即多个客户可以同时读取同一个资源，但不允许其他客户修改。

* 排他锁（X锁、写锁)： 允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的读锁和写锁。写锁是排他的，写锁会阻塞其他的写锁和读锁。

另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
* 意向共享锁（IS）： 事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

* 意向排他锁（IX）： 事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

### 1、InnoDB 行锁实现方式：
* InnoDB 行锁是通过给索引上的索引项加锁来实现的，所以只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！
* 不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。
* 只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。
* 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个session是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的session需要等待先使用索引的session释放锁后，才能获取锁）。 应用设计的时候要注意这一点。

## 四、事务的隔离级别
事务的隔离级别就是通过锁的机制来实现，锁的应用最终导致不同事务的隔离级别，只不过隐藏了加锁细节，事务的隔离级别有4种：

* Read uncommitted：会出现脏读，不可重复读，幻读

* Read committed：会出现不可重复读，幻读

* Repeatable read：会出现幻读(Mysql默认的隔离级别，但是Repeatable read配合gap锁不会出现幻读！)

* Serializable：串行，避免以上的情况

## 五、MVCC行级锁
MVCC(Multi-Version ConcurrencyControl)多版本并发控制，可以简单地认为：**MVCC就是行级锁的一个变种(升级版)。**

在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般读写是不阻塞的(很多情况下避免了加锁的操作)。

可以简单的理解为：对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。

## 六、乐观锁和悲观锁
无论是Read committed还是Repeatable read隔离级别，都是为了解决读写冲突的问题，现在考虑一个问题：有一张数据库表USER，只有id、name字段，现在有2个请求同时操作表A，过程如下：（模拟更新丢失，虽然不是很恰当）
* 操作1查询出name="zhangsan"
* 操作2也查询出name="zhangsan"
* 操作1把name字段数据修改成lisi并提交
* 操作2把name字段数据修改为wangwu并提交

那么操作1的更新丢失啦，即一个事务的更新覆盖了其它事务的更新结果，解决上述更新丢失的方式有如下3种：
* 使用Serializable隔离级别，事务是串行执行的！
* 乐观锁
* 悲观锁

### 1、悲观锁
顾名思义，就是对于数据的处理持悲观态度，总认为会发生并发冲突，获取和修改数据时，别人会修改数据。所以在整个数据处理过程中，需要将数据锁定。

悲观锁的实现，通常依靠数据库提供的锁机制实现，比如mysql的排他锁，select .... for update来实现悲观锁。

```sql
#1、开启事务，查询要卖的商品，并对该记录加锁。
begin;
select nums from tb_goods_stock where goods_id = {$goods_id} for update;

#2、判断商品数量是否大于购买数量。如果不满足，就回滚事务。

#3、如果满足条件，则减少库存，并提交事务。
update tb_goods_stock set nums = nums - {$num} where goods_id = {$goods_id} and nums >= {$num};

commit;
```

在select 语句后边加了for update相当于加了排它锁(写锁)，加了写锁以后，其他事务就不能对它修改了。需要等待当前事务修改完之后才可以修改。

### 2、乐观锁
顾名思义，就是对数据的处理持乐观态度，乐观的认为数据一般情况下不会发生冲突，只有提交数据更新时，才会对数据是否冲突进行检测。

如果发现冲突了，则返回错误信息给用户，让用户自已决定如何操作。

**乐观锁的实现不依靠数据库提供的锁机制，需要我们自已实现**。实现方式一般是记录数据版本，一种是通过版本号，一种是通过时间戳。

给表加一个版本号或时间戳的字段，读取数据时，将版本号一同读出，数据更新时，将版本号加1。

当我们提交数据更新时，判断当前的版本号与第一次读取出来的版本号是否相等。如果相等，则予以更新，否则认为数据过期，拒绝更新，让用户重新操作。

例如操作1和操作2在更新User表的时，执行语句如下：
```sql
begin;
select nums, version from tb_goods_stock where goods_id = {$goods_id};

update tb_goods_stock set nums = nums - {$num}, version = version + 1 where goods_id = {$goods_id} and version = {$version} and nums >= {$num};

#判断更新操作是否成功执行，如果成功，则提交，否则就回滚。
```

乐观锁是基于程序实现的，所以不存在死锁的情况，适用于读多的应用场景。如果经常发生冲突，上层应用不断的让用户进行重新操作，这反而降低了性能，这种情况下悲观锁就比较适用。

## 七、间隙锁GAP
当我们用范围条件检索数据而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合范围条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”。InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。

间隙锁（Gap Lock）是Innodb在`可重复读提交`下为了解决幻读问题时引入的锁机制。
    
**详见‘mysql间隙锁’那节。**

## 八、死锁
### 1、产生原因
* 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

* 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。

### 2、特点
* **表级锁不会产生死锁。**所以解决死锁主要还是针对于最常用的InnoDB。

* 死锁的关键在于：**两个(或以上)的Session加锁的顺序不一致。**

* 那么对应的解决死锁问题的关键就是：**让不同的session加锁有次序。**

### 3、产生示例
需求：将投资的钱拆成几份随机分配给借款人。

起初业务程序思路是这样的：
投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条select for update 去更新借款人表里面的余额等。

例如：
* 两个用户同时投资，A用户金额随机分为2份，分给借款人1，2
* B用户金额随机分为2份，分给借款人2，1，由于加锁的顺序不一样，死锁当然很快就出现了。

对于这个问题的改进很简单，直接先把所有分配到的借款人直接一次锁住就行了。
```sql
Select * from xxx where id in (xx,xx,xx) for update
```
**在in里面的列表值mysql是会自动从小到大排序，加锁也是一条条从小到大加的锁。**

### 4、InnoDB避免死锁
* 为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元素（行）使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。
* 在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁
* 如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会
* 通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。
* 改变事务隔离级别。

## 九、手动加锁
### 1、InnoDB加锁
* 意向锁是 InnoDB 自动加的， 不需用户干预。
* 对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB会自动给涉及数据集加排他锁（X)；
* 对于普通 SELECT 语句，InnoDB 不会加任何锁；
* `事务`可以通过以下语句显式给记录集加共享锁或排他锁：
    共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
    
    排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE(这个语句对应的锁就相当于update带来的效果)。
    
##### 隐式锁定：
InnoDB在事务执行过程中，使用两阶段锁协议：
* 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁；

* 锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是在同一时刻被释放。

##### 显式锁定 ：
```sql
select ... lock in share mode //共享锁 
select ... for update //排他锁 
```

### 2、MyISAM加锁
* MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁。
* 在执行增、删、改操作前，会自动给涉及的表加写锁。(既MyISAM存储引擎中，当执行SQL语句的时候是自动加锁的。)

## 十、LOCK TABLES 和 UNLOCK TABLES
**Mysql也支持lock tables和unlock tables，这都是在服务器层（MySQL Server层）实现的，和存储引擎无关**。它们有自己的用途，并不能替代事务处理。 （除了禁用了autocommint后可以使用，其他情况不建议使用）：
* LOCK TABLES 可以锁定用于当前线程的表。如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止。
* UNLOCK TABLES 可以释放当前线程获得的任何锁定。当前线程执行另一个 LOCK TABLES 时，或当与服务器的连接被关闭时，所有由当前线程锁定的表被隐含地解锁

### 1、LOCK TABLES语法：
* 在用 LOCK TABLES 对 InnoDB 表加锁时要注意，要将 AUTOCOMMIT 设为 0，否则MySQL 不会给表加锁；
* 事务结束前，不要用 UNLOCK TABLES 释放表锁，因为 UNLOCK TABLES会隐含地提交事务；
* COMMIT 或 ROLLBACK 并不能释放用 LOCK TABLES 加的表级锁，必须用UNLOCK TABLES 释放表锁。

加锁语句
* LOCK TABLES t1 WRITE:加S锁
* LOCK TABLES t2 READ:加X锁

如下语句：
例如，如果需要写表 t1 并从表 t 读，可以按如下做：
```sql
SET AUTOCOMMIT=0; 
LOCK TABLES t1 WRITE, t2 READ, ...; 
[do something with tables t1 and t2 here]; 
COMMIT; 
UNLOCK TABLES;
```

### 2、使用LOCK TABLES的场景：
给表显示加表级锁（InnoDB表和MyISAM都可以），一般是为了在一定程度模拟事务操作，实现对某一时间点多个表的一致性读取。（与MyISAM默认的表锁行为类似）

在用 LOCK TABLES 给表显式加表锁时，必须同时取得所有涉及到表的锁，并且 MySQL 不支持锁升级。也就是说，在执行 LOCK TABLES 后，只能访问显式加锁的这些表，不能访问未加锁的表；同时，如果加的是读锁，那么只能执行查询操作，而不能执行更新操作。

其实，在MyISAM自动加锁（表锁）的情况下也大致如此，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。

例如，有一个订单表 orders，其中记录有各订单的总金额 total，同时还有一个 订单明细表 order_detail，其中记录有各订单每一产品的金额小计 subtotal，假设我们需要检 查这两个表的金额合计是否相符，可能就需要执行如下两条 SQL：

```sql
Select sum(total) from orders; 
Select sum(subtotal) from order_detail; 
```
这时，如果不先给两个表加锁，就可能产生错误的结果，因为第一条语句执行过程中，
order_detail 表可能已经发生了改变。因此，正确的方法应该是：

```sql
Lock tables orders read local, order_detail read local; 
Select sum(total) from orders; 
Select sum(subtotal) from order_detail; 
Unlock tables;
```

（在 LOCK TABLES 时加了“local”选项，其作用就是允许当你持有表的读锁时，其他用户可以在满足 MyISAM 表并发插入条件的情况下，在表尾并发插入记录（MyISAM 存储引擎支持“并发插入”））

## 十一、InnoDB和MyISAM的锁区别
* InnoDB行锁和表锁都支持、MyISAM只支持表锁！
* 在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。
* MyISAM存储引擎支持并发插入，以减少给定表的读和写操作之间的争用。

* 在InnoDB存储引擎中，如果没有使用索引，表锁也是自动加的。

## 十二、锁总结

### 1、为什么MyISAM表不太适合于有大量更新操作和查询操作
因为大量的更新操作会造成查询操作很难获得读锁，从而可能永远阻塞。同时，一些需要长时间运行的查询操作，也会使写线程“饿死” ，应用中应尽量避免出现长时间运行的查询操作（在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。

### 2、其他
* 排他锁/记录锁、间隙锁、临键锁都是排它锁。
* 查询表级锁争用情况：
  可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：

    ```sql
    mysql> SHOW STATUS LIKE 'Table%';