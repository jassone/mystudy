## 缓存更新问题

### 一、数据更新后，更新缓存还是淘汰缓存？
主要取决于`更新缓存的复杂度`。

从缓存结果获取来看
* 如果更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率。
* 如果缓存结果是通过很复杂的数据计算得出来的，倾向于删除缓存

从缓存数据对象来看
* 对于对象类型，或者json文本类型，修改缓存value的成本较高，一般选择直接淘汰缓存。

    1) 序列化后的对象：一般需要先get数据，反序列化成对象，修改其中的成员，再序列化为binary，再set数据
    2) json或者html数据：一般也需要先get文本，parse成doom树对象，修改相关元素，序列化为文本，再set数据

* 对于简单的数据类型，可以选择修改缓存。

当然，绝大部分情况下，如果选择淘汰缓存，只会额外增加一次cache miss，成本也不高。

### 二、数据更新时，先操作缓存，还是数据库？
要保证两个操作的原子性，要么同时成功，要么同时失败。

这演变为一个分布式事务的问题，保证原子性十分困难，很有可能出现一半成功，一半失败，接下来看下，当原子性被破坏的时候，分别会发生什么。

##### 1 先操作数据库，再操作缓存
（1）先操作数据库，成功；
（2）再操作缓存（delete或者set），也成功；

但如果这两个动作原子性被破坏：第一步成功，第二步失败，会导致，数据库里是新数据，而缓存里是旧数据，业务无法接受。

> 画外音：如果第一步就失败，可以返回调用方50X，不会出现数据不一致。

##### 2 先操作缓存，再操作数据库
（1）先操作缓存（delete或者set），成功；
（2）再操作数据库，也成功；

> 画外音：如果第一步就失败，也可以返回调用方50X，不会出现数据不一致。

如果原子性被破坏，会发生什么呢？

这里又分了两种情况：
（1）操作缓存使用set
（2）操作缓存使用delete

使用set的情况：第一步成功，第二步失败，会导致，缓存里是set后的数据，数据库里是之前的数据，数据不一致，业务无法接受。
并且，一般来说，`数据最终以数据库为准`，写缓存成功，其实并不算成功。

使用delete的情况：第一步成功，第二步失败，会导致，缓存里没有数据，数据库里是之前的数据，数据没有不一致，对业务无影响。只是下一次读取，会多一次cache miss。

> 画外音：此时可以返回调用方50X。

##### 3 最终，先操作缓存，还是先操作数据库？
1) 先缓存，再数据
2) 缓存，使用delete，而不是set

##### 4 结论强调
（1）淘汰缓存是一种通用的缓存处理方式
（2）先淘汰缓存，再写数据库的时序是毋庸置疑的
（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式

### 三、cache aside pattern 术语解释：
cache aside pattern是最经典的缓存+数据库读写的模式。

* 如果应用程序更新信息，则可以通过对数据存储进行修改，并使缓存中的相应项目无效，从而遵循直写策略。
* 当下一个项目需要时，使用cache-aside策略将导致更新的数据从数据存储中检索并添加到高速缓存中。

简单大白话如下：
    (1).读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应
    (2).更新的时候，先删除缓存，然后再更新数据库
    
