## 缓存更新问题

## 一、相关问题

### 1、数据更新后，更新缓存还是淘汰缓存？

主要取决于`更新缓存的复杂度`。

从缓存结果获取来看
* 如果更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率。
* 如果缓存结果是通过很复杂的数据计算得出来的，倾向于删除缓存

从缓存数据对象来看
* 对于对象类型，或者json文本类型，修改缓存value的成本较高，一般选择直接淘汰缓存。

    1) 序列化后的对象：一般需要先get数据，反序列化成对象，修改其中的成员，再序列化为binary，再set数据
    2) json或者html数据：一般也需要先get文本，parse成dom树对象，修改相关元素，序列化为文本，再set数据

* 对于简单的数据类型，可以选择修改缓存。

当然，绝大部分情况下，如果选择淘汰缓存，只会额外增加一次cache miss，成本也不高。

## 二、缓存不一致解决方案-主从数据库

### 1 数据库主从，为什么会不一致？

原因是主动同步完成之前，会读取到旧数据。

可以看到，主从不一致的影响时间很短，在主从同步完成后，就会读到新数据。

### 2 缓存与数据库，什么时候会不一致？

再看，引入缓存后，缓存和数据库不一致问题。

![20221226170542.jpg](https://pic.imgdb.cn/item/61c830882ab3f51d91bd006e.jpg)

如上图，发生的场景也是，写后立刻读：
（1+2）先一个写请求，淘汰缓存，写数据库；
（3+4+5）接着立刻一个读请求，读缓存，cache miss，读从库，写缓存放入数据，以便后续的读能够cache hit（主从同步没有完成，缓存中放入了旧数据）；
（6）最后，主从同步完成；

导致的结果是：旧数据放入缓存，即使主从同步完成，后续仍然会从缓存一直读取到旧数据。

可以看到，加入缓存后，导致的不一致影响时间会很长，并且最终也不会达到一致。

### 3 为什么会出现这类不一致？

可以看到，这里提到的缓存与数据库数据不一致，根本上是由数据库主从不一致引起的。当主库上发生写操作之后，从库binlog同步的时间间隔内，读请求，可能导致有旧数据入缓存。

假如主从不一致没法彻底解决，引入缓存之后，binlog同步时间间隔内，也无法避免读旧数据。

但是，有没有办法做到，即使引入缓存，不一致不会比“不引入缓存”更糟呢？这是更为实际的优化目标。

思路转化为：`在从库同步完成之后，如果有旧数据入缓存，应该及时把这个旧数据淘汰掉`。

### 4 缓存与数据库不一致，可以怎么优化？

![20221226170601.jpg](https://pic.imgdb.cn/item/61c830a92ab3f51d91bd0c18.jpg)

如上图所述，在并发读写导致缓存中读入了脏数据之后：
（6）主从同步；
（7）通过工具订阅从库的binlog，这里能够最准确的知道，从库数据同步完成的时间；

> 画外音：本图画的订阅工具是DTS(数据传输服务)，可以是cannal，也可以自己订阅和分析binlog。

（8）从库执行完写操作，向缓存再次发起删除，淘汰这段时间内可能写入缓存的旧数据；

如此这般，至少能够保证，引入缓存之后，主从不一致 ，不会比没有引入缓存更坏。

## 三、缓存模式

### 1、cache aside：

cache aside  (旁路缓存) 是最经典的缓存+数据库读写的模式。

* 如果应用程序更新信息，则可以通过对数据存储进行修改，并使缓存中的相应项目无效，从而遵循直写策略。
* 当下一个项目需要时，使用cache-aside策略将导致更新的数据从数据存储中检索并添加到高速缓存中。

简单大白话如下：
    (1).读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应
    (2).更新的时候，先删除缓存，然后再更新数据库

### 2、Read Through

`Read-Through`和`Cache-Aside`很相似，不同点在于程序不需要再去管理从哪去读数据（缓存还是数据库）。相反它会直接从缓存中读数据，该场景下是缓存去决定从哪查询数据。当我们比较两者的时候这是一个优势因为它会让程序代码变得更简洁。

因为回源操作交给了缓存组件来操作，业务不需要关心回源的细节。

### 3、Write-Through

`Write-Through`下所有的写操作都经过缓存，每次我们向缓存中写数据的时候，缓存会把数据持久化到对应的数据库中去，且这两个操作都在一个事务中完成。因此，只有两次都写成功了才是最终写成功了。这的确带来了一些写延迟但是它保证了数据一致性。

同时，因为程序只和缓存交互，编码会变得更加简单和整洁，当你需要在多处复用相同逻辑的时候这点变的格外明显。

当使用`Write-Through`的时候一般都配合使用`Read-Through`。

`Write-Through`适用情况有：

- 需要频繁读取相同数据
- 不能忍受数据丢失（相对`Write-Behind`而言）和数据不一致

**`Write-Through`的潜在使用例子是银行系统。**

### 4、Write-Behind

`Write-Behind`和`Write-Through`在“程序只和缓存交互且只能通过缓存写数据”这一点上很相似。不同点在于`Write-Through`会把数据立即写入数据库中，而`Write-Behind`会在一段时间之后（或是被其他方式触发）把数据一起写入数据库，这个异步写操作是`Write-Behind`的最大特点。

数据库写操作可以用不同的方式完成，其中一个方式就是收集所有的写操作并在某一时间点（比如数据库负载低的时候）批量写入。另一种方式就是合并几个写操作成为一个小批次操作，接着缓存收集写操作（比如5个）一起批量写入。

异步写操作极大的降低了请求延迟并减轻了数据库的负担。同时也放大了数据不一致的。比如有人此时直接从数据库中查询数据，但是更新的数据还未被写入数据库，此时查询到的数据就不是最新的数据。

