## 缓存更新问题

## 一、相关问题

### 1、数据更新后，更新缓存还是淘汰缓存？

主要取决于`更新缓存的复杂度`。

从缓存结果获取来看
* 如果更新缓存的代价很小，此时我们应该更倾向于更新缓存，以保证更高的缓存命中率。
* 如果缓存结果是通过很复杂的数据计算得出来的，倾向于删除缓存

从缓存数据对象来看
* 对于对象类型，或者json文本类型，修改缓存value的成本较高，一般选择直接淘汰缓存。

    1) 序列化后的对象：一般需要先get数据，反序列化成对象，修改其中的成员，再序列化为binary，再set数据
    2) json或者html数据：一般也需要先get文本，parse成dom树对象，修改相关元素，序列化为文本，再set数据

* 对于简单的数据类型，可以选择修改缓存。

当然，绝大部分情况下，如果选择淘汰缓存，只会额外增加一次cache miss，成本也不高。

### 2、数据更新时，先操作缓存，还是数据库？

要保证两个操作的原子性，要么同时成功，要么同时失败。

这演变为一个分布式事务的问题，保证原子性十分困难，很有可能出现一半成功，一半失败，接下来看下，当原子性被破坏的时候，分别会发生什么。

##### 1 先操作数据库，再操作缓存
（1）先操作数据库，成功；
（2）再操作缓存（delete或者set），也成功；

但如果这两个动作原子性被破坏：第一步成功，第二步失败，会导致，数据库里是新数据，而缓存里是旧数据，业务无法接受。

> 画外音：如果第一步就失败，可以返回调用方50X，不会出现数据不一致。

##### 2 先操作缓存，再操作数据库

（1）先操作缓存（delete或者set），成功；
（2）再操作数据库，也成功；

> 画外音：如果第一步就失败，也可以返回调用方50X，不会出现数据不一致。

如果原子性被破坏，会发生什么呢？

这里又分了两种情况：
（1）操作缓存使用set
（2）操作缓存使用delete

使用set的情况：第一步成功，第二步失败，会导致，缓存里是set后的数据，数据库里是之前的数据，数据不一致，业务无法接受。
并且，一般来说，数据最终以数据库为准，写缓存成功，其实并不算成功。

使用delete的情况：第一步成功，第二步失败，会导致，缓存里没有数据，数据库里是之前的数据，数据没有不一致，对业务无影响。只是下一次读取，会多一次cache miss。

> 画外音：此时可以返回调用方50X。

##### 3 最终，先操作缓存，还是先操作数据库？
1) 先操作缓存，再操作数据
2) 缓存，使用delete，而不是set

##### 4 结论强调
（1）淘汰缓存是一种通用的缓存处理方式
（2）**先淘汰缓存，再写数据库的时序是毋庸置疑的**
（3）服务化是向业务方屏蔽底层数据库与缓存复杂性的一种通用方式

## 二、缓存模式

### 1、cache aside：

cache aside  (旁路缓存) 是最经典的缓存+数据库读写的模式。

* 如果应用程序更新信息，则可以通过对数据存储进行修改，并使缓存中的相应项目无效，从而遵循直写策略。
* 当下一个项目需要时，使用cache-aside策略将导致更新的数据从数据存储中检索并添加到高速缓存中。

简单大白话如下：
    (1).读的时候，先读缓存，缓存没有的话，那么就读数据库，然后取出数据后放入缓存，同时返回响应
    (2).更新的时候，先删除缓存，然后再更新数据库

### 2、Read Through

`Read-Through`和`Cache-Aside`很相似，不同点在于程序不需要再去管理从哪去读数据（缓存还是数据库）。相反它会直接从缓存中读数据，该场景下是缓存去决定从哪查询数据。当我们比较两者的时候这是一个优势因为它会让程序代码变得更简洁。

因为回源操作交给了缓存组件来操作，业务不需要关心回源的细节。

### 3、Write-Through

`Write-Through`下所有的写操作都经过缓存，每次我们向缓存中写数据的时候，缓存会把数据持久化到对应的数据库中去，且这两个操作都在一个事务中完成。因此，只有两次都写成功了才是最终写成功了。这的确带来了一些写延迟但是它保证了数据一致性。

同时，因为程序只和缓存交互，编码会变得更加简单和整洁，当你需要在多处复用相同逻辑的时候这点变的格外明显。

当使用`Write-Through`的时候一般都配合使用`Read-Through`。

`Write-Through`适用情况有：

- 需要频繁读取相同数据
- 不能忍受数据丢失（相对`Write-Behind`而言）和数据不一致

**`Write-Through`的潜在使用例子是银行系统。**

### 4、Write-Behind

`Write-Behind`和`Write-Through`在“程序只和缓存交互且只能通过缓存写数据”这一点上很相似。不同点在于`Write-Through`会把数据立即写入数据库中，而`Write-Behind`会在一段时间之后（或是被其他方式触发）把数据一起写入数据库，这个异步写操作是`Write-Behind`的最大特点。

数据库写操作可以用不同的方式完成，其中一个方式就是收集所有的写操作并在某一时间点（比如数据库负载低的时候）批量写入。另一种方式就是合并几个写操作成为一个小批次操作，接着缓存收集写操作（比如5个）一起批量写入。

异步写操作极大的降低了请求延迟并减轻了数据库的负担。同时也放大了数据不一致的。比如有人此时直接从数据库中查询数据，但是更新的数据还未被写入数据库，此时查询到的数据就不是最新的数据。
